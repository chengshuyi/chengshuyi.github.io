<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">程书意</title>
    <subtitle type="html">MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</subtitle>
    <updated>2020-04-22T11:16:39+00:00</updated>
    <id>https://chengshuyi.github.io/</id>
    <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/" />
    <link rel="self" type="application/atom+xml" href="https://chengshuyi.github.io/atom.xml" />
    <author>
            <name>程书意</name>
            <uri>https://chengshuyi.github.io/</uri>
            
                <email>c15271843451@outlook.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.68.3">Hugo</generator>
        <entry>
            <title type="text">嵌入式文件系统</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/embedded-file-system/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" />
            <id>https://chengshuyi.github.io/posts/embedded-file-system/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-21T14:11:20+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[嵌入式采用的存储设备一般是flash，由于flash同块设备有很较大的差异，因此并不能在flash设备上采用通用文件系统，比如Fat、Ext等等。现在对flash存储器……]]></summary>
            
                <content type="html"><![CDATA[<p>嵌入式采用的存储设备一般是flash，由于flash同块设备有很较大的差异，因此并不能在flash设备上采用通用文件系统，比如Fat、Ext等等。现在对flash存储器的文件系统越来越多了，主要可以分成两大类：一类是基于转译层和块的设备文件系统，另一类是基于日志结构的文件系统。</p>
<p>基于转译层的文件系统之所以称为基于转译层，是因为在文件系统和flash设备之间有一个中间层叫转译层。这个转译层可以将 Flash 设备模拟成块设备，以供文件系统控制和使用。而基于日志结构的文件系统又可以分为两大类：一类是通用的flash文件系统，一类是专用的flash文件系统。通用的文件系统可以在nor flash上运行，也可以在nand flash上运行。以 jffs为代表的文件系统就是这样的通用 flash文件系统。另一类专业的flash文件系统指的是专门针对flash的文件系统，以yaffs系列的文件系统为代表<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。 具体可以参看下图<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200422073948.png" alt=""></p>
<p>本文首先介绍了flash的特性，最后介绍了flash上常用的文件系统，以及对应的数据压缩技术、坏块管理技术、磨损均衡技术和垃圾回收技术。</p>
<h3 id="flash介绍12">flash介绍<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup><sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></h3>
<p>flash存储器，也叫快擦写存储器，和磁盘设备相比，flash存储器在体积、扩展性、耗电等方面都有着显著的优势，因此成为了嵌入式系统首选的存储设备。</p>
<p>flash属于非易失性半导体存储器，其类型目前主要两种：nor flash和nand flash。  nand flash广泛应用在各种存储卡、U盘、SSD、eMMC等等大容量设备中。nor flash 能快速随机读取，允许系统直接从存储器中读取代码执行即芯片内执行技术（eXecute In Place），而无需先将代码下载至RAM中再执行，可以像普通ROM一样执行程序。</p>
<p>flash存储器的擦除次数是有限的，一般是$10^6$次。当某块执行过度的擦除操作后，这一块的存储空间将会变为“只读”状态，不能再写入数据。flash存储器也存在着两个主要缺陷：</p>
<ul>
<li>一是在重写之前必须进行擦除，因为flash存储器划分成很多擦除块（sector-erase），对任何一位数据进行修改必须先擦除整个块（sector）；</li>
<li>二是擦除块的擦除次数有限，当一个块提前达到擦除次数上限时，将导致整个存储器无法使用。</li>
</ul>
<h4 id="nor-flash">nor flash</h4>
<p>Intel于1988年首先开发出nor flash存储器技术，这也是最早出现的flash存储器技术，目前主要由供应商Intel与AMD支持，主要应用于擦除和编程操作较少而直接执行代码的场合，尤其是纯代码存储应用的理想选择，如PC的BIOS固件、移 动电话、嵌入式系统中装载启动代码等。其特点如下：</p>
<ul>
<li>又名线性flash存储器；</li>
<li>能快速随机读取，允许系统直接从存储器中读取代码执行即芯片内执行技术（eXecute In Place），而无需先将代码下载至RAM中再执行；</li>
<li>可以单字节或单字编程，但不能单字节擦除，必须以块为单位或对整片进行擦除操作，重新编程之前需要先擦后写。因执行一个编程擦除操作时间较慢（大约5秒），而块尺寸又较大（64KB-128KB），于是在纯数据存储应用中花费的时间较长。</li>
</ul>
<h4 id="nand-flash">nand flash</h4>
<p>自1989年东芝公司开发出nand flash以来，如今主要由三星、富士通及东芝等日韩厂商大力支持，这种结构的存储器适合于数据和文件存储，主要作为SM卡、CF卡、PCMCIA卡、固态盘的存储介质，并正成存储器技术的核心。其特点如下：</p>
<ul>
<li>又名非线性flash存储器；</li>
<li>以页（256B-512B）为单位进行读和编程操作，以块(4KB-32KB)为单位进行擦除操作,编程擦除时间短一般每块时间为4ms；</li>
<li>实现串行读取，随机读取速度慢且不能按字节随机编程；</li>
<li>芯片尺寸小，引脚少，是位成本最低的固态存储器；</li>
<li>芯片包含有失效块，其数目最大可达到3-35块（取决于存储器密度），失效块虽不影响有效块的性能，但设计者仍需要在地址映射表中屏蔽它。</li>
</ul>
<h4 id="对比表格">对比表格</h4>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">nor flash</th>
<th align="center">nand flash</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">存储容量</td>
<td align="center">小，一般1MB-32MB</td>
<td align="center">大，一般8MB-512MB</td>
</tr>
<tr>
<td align="center">擦除块大小</td>
<td align="center">64KB-256KB</td>
<td align="center">6KB-128KB，每块被分为若干个512Bytes的页面，每页面含有16Bs附加存储区</td>
</tr>
<tr>
<td align="center">读写方式</td>
<td align="center">线形时间按字节随机读写</td>
<td align="center">以页面为单位读写类似磁盘</td>
</tr>
<tr>
<td align="center">读写速度</td>
<td align="center">读取快，写入慢</td>
<td align="center">快，2ms-5ms/块</td>
</tr>
<tr>
<td align="center">擦除时间</td>
<td align="center">慢，2s-5s/块</td>
<td align="center">高，出场可能有坏道</td>
</tr>
<tr>
<td align="center">坏块比例</td>
<td align="center">低，出厂一般没有坏道</td>
<td align="center">高存储密度，尺寸小，价格低</td>
</tr>
<tr>
<td align="center">价格</td>
<td align="center">低存储密度，尺寸大，价格高</td>
<td align="center">接串行总线，I/O接口</td>
</tr>
<tr>
<td align="center">接口形式</td>
<td align="center">接并行总线，内存接口</td>
<td align="center">接串行总线，I/O接口</td>
</tr>
<tr>
<td align="center">寿命</td>
<td align="center">十万次级</td>
<td align="center">百万次级</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">高，位交换几率低</td>
<td align="center">低，位交换几率高，必须采用错误探测/错误更 正（EDC/ECC）算法</td>
</tr>
<tr>
<td align="center">XIP</td>
<td align="center">可以</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">易用性</td>
<td align="center">容易</td>
<td align="center">复杂，一般需要MTD驱动支持</td>
</tr>
<tr>
<td align="center">设计目的</td>
<td align="center">作为ROM的替代产品</td>
<td align="center">磁盘</td>
</tr>
<tr>
<td align="center">编程方式</td>
<td align="center">允许逐字节编程</td>
<td align="center">页面编程，且每个页面的编程次数有限制</td>
</tr>
</tbody>
</table>
<h3 id="基于flash的文件系统">基于flash的文件系统</h3>
<p>flash存储器的擦除次数是有限的，一般是$10^6$次。当某块执行过度的擦除操作后，这一块的存储空间将会变为“只读”状态，不能再写入数据。根据以上特点，为了避免某些块的过度操作，而导致存储卡使用寿命降低，设计专门针对flash存储器的文件系统是必要的。嵌入式文件系统要考虑得特性<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>：</p>
<ul>
<li>数据压缩：通过压缩算法不仅可以降低数据的容量，而且间接的加速了I/O；</li>
<li>坏块管理：坏块通常使用带外区域中的特定标记来标识；</li>
<li>磨损均衡：由于flash存储芯片的擦除次数是有限制的，文件系统对存储器使用时必须充分考虑这个特性，因此最好能均匀使用存储芯片的每个扇区，以延长存储器的使用寿命。</li>
<li>垃圾回收：</li>
</ul>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200421232912.png" alt=""></p>
<h4 id="jffs23">jffs2<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></h4>
<p>jffs文件系统最早是由瑞典Axis Communications公司基于Linux2.0的内核为嵌入式系统开发的文件系统。jffs2是一个可读写的、压缩的、日志型文件系统，并提供了崩溃掉电安全保护，克服了jffs的一些缺点：使用了基于哈希表的日志节点结构,大大加快了对节点的操作速度；支持数据压缩；提供了“写平衡”支持；支持多种节点类型；提高了对flash存储器的利用率，降低了内存的消耗。它的缺点就是当文件系统己满或接近满时，运行会变慢，这主要是因为垃圾回收的问题。</p>
<h5 id="数据压缩">数据压缩</h5>
<p>jffs2提供了jffs所没有的数据压缩技术。数据在存放到flash之前会先被压缩，这个过程是由jffs2自动完成。因
此，在使用jffs2时无需自己对数据进行压缩。各种类型的压缩算法皆可内嵌到系统中去，目前jffs2使用的是zlib算
法。该算法比较适合ASCII文件，若压缩对象是二进制文件，压缩效果并不明显。</p>
<h5 id="坏块管理">坏块管理</h5>
<p>暂无</p>
<h5 id="磨损均衡">磨损均衡</h5>
<p>jffs并没有采用磨损均衡技术，到了jffs2才使用此技术。磨损均衡技术的引入提高了flash的使用寿命期限。jffs2改变了jfss没有块队列的状态，将flash各个块（block）分成三个队列：脏块队列（dirty_list）、干净块队列（clean_list）以及空闲块队列。脏块是指该块上至少有一个节点被标记为废弃（obsoleted）；干净块是指块上
的数据皆有效。工作流程如下：</p>
<ol>
<li>当系统的空闲块数小于6时，GC进程会被唤醒；</li>
<li>判断jiffies计数器的值，如果jiffies% 100非零，选中脏块队列。否则，将选中干净块队列。（很显然,如果存在脏块的话，选中后者的概率仅为1%。）</li>
<li>如果选中的是脏块队列，则直接进行擦写操作，最后把它挂接到空闲块队列；</li>
<li>如果选中的是干净块队列，则被选中的干净块中的所有数据要被全部移至其它空闲块中，接着对该块进行擦写操作，最后把它挂接到空闲块队列。</li>
</ol>
<h5 id="垃圾回收">垃圾回收</h5>
<p>jffs2的垃圾收集技术的原理：当需要增添新内容时，就在节点链表的末端添加新的节点存储新的内容；若要修改文
件的某部分，jffs2将该部分<strong>标记为废弃</strong>，并在节点<strong>链表末端添加修改后的内容</strong>。JFFS2如此不断地在flash上添加新的内容，当flash上的存储空间用完时,系统就回收标记为废弃的空间，该过程就称为垃圾收集。垃圾收集进程(简称GC进程)专门负责该项工作。下面是jffs2 GC进程的工作流程：</p>
<ol>
<li>当系统的空闲块数小于6时，GC进程会被唤醒；</li>
<li>GC进程每次只回收一个空闲块；</li>
<li>如果此时flash上的空闲块数仍小于6，那么GC进程必须再回收一个空闲块，直到总的空闲块数达到6为止。</li>
</ol>
<h4 id="yaffs27">yaffs2<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></h4>
<h5 id="数据压缩-1">数据压缩</h5>
<p>暂无</p>
<h5 id="坏块管理-1">坏块管理</h5>
<p>暂无</p>
<h5 id="磨损均衡-1">磨损均衡</h5>
<p>yaffs2 并未实现真正的磨损均衡算法，而是通过<strong>顺序写策略和串行块分配策略</strong>将擦除次数尽可能均匀地分布在闪存空间上，测试结果表明其均衡效果较好，但忽略了静态数据和“冷”数据的影响，因此是一种局部的磨损均衡机制，有待进一步的改进。</p>
<p>顺序写策略：</p>
<p>串行块分配策略：</p>
<h5 id="垃圾回收-1">垃圾回收</h5>
<p>yaffs2垃圾回收操作一般在向文件写数据（函数 yaffs_wr_data_obj）、更新对象头（函数 yaffs_update_oh）和文件截短操作（函数 yaffs_resize_file）等过程中被调用，由函数yaffs_check_gc视当前闪存空间使用情况决定是否触发垃圾回收操作。YAFFS2 的垃圾回收操作分三步进行：</p>
<ol>
<li>查找到满足回收条件的目标回收块（由函数yaffs_find_gc_block 函数完成），若未找到，则退出；</li>
<li>遍历块中所有页，若页中存放有效数据，则将数据复制到其它块中的空闲页中，然后删除该页，并修改内存中记录闪存空间使用信息的数据结构（如块信息结构 yaffs_block_info，页位图数组 chunk_bits 等）以体现
闪存空间使用情况的变化（由函数 yaffs_gc_process_chunk 完成）；</li>
<li>当块中所有 chunk 都被删除后，则擦除该块（由函数 yaffs_block_became_dirty 完成），使其可以被再次写入数据。</li>
</ol>
<h4 id="ubifs4">ubifs<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h4>
<p>ubifs文件系统主要包含ubifs和ubi模块，ubifs模块建立在ubi模块的基础上，ubi模块是建立在mtd模块基础上的。三个模块整体关系如下图<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200421234706.png" alt=""></p>
<p>ubifs的设计主要是为了解决jffs2文件系统存在的启动时间长、系统扩展性差、内存消耗量大、损耗均衡处理能力差等问题。jffs2的挂载时间是与闪存大小成线性比的（扫描所有的块），ubifs克服了这一弱点（ubi子模块挂载时间还是与闪存大小成线性比的）。</p>
<p>ubifs同jffs2的三个主要区别：</p>
<ul>
<li>jffs2将索引（inode）节点存储在内存上，ubifs将索引节点存储在闪存上 ；</li>
<li>运行在MTD设备层之上，ubifs运行在ubi层之上；</li>
<li>jffs2不支持回写（write-back），而ubifs支持回写技术。</li>
</ul>
<h5 id="坏块管理-2">坏块管理</h5>
<p>ubi在两种情况下认为peb（physical erase block）已损耗：</p>
<ul>
<li>写peb失败，此时，ubi把这个peb的数据搬移到其他的peb，然后诊断该peb是否出现为坏块，如果是，标记为坏块；</li>
<li>擦除操作出现I/O错误，在这种情况下，直接把peb标记为坏块。</li>
</ul>
<h5 id="磨损均衡-2">磨损均衡</h5>
<p>暂无</p>
<h5 id="垃圾回收-2">垃圾回收</h5>
<p>暂无</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>周林. 通用嵌入式文件系统YAFFS的移植[D]. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>冯子陵. 闪存文件系统UBIFS的分析与优化[D]. 2013. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/Toshiba%20NAND_vs_NOR_Flash_Memory_Technology_Overviewt.pdf">NAND vs. NOR Flash MemoryTechnology Overview</a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>孙健. 基于Flash存储器的嵌入式文件系统的研究与实现[D]. 西安电子科技大学. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>李桂良, 刘发贵. JFFS2文件系统的关键技术及其在嵌入式系统的应用[J]. 计算机应用, 2003(07):137-139. <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>[优质文章]李恒恒. 基于YAFFS2文件系统的NAND Flash存储管理关键技术研究[D]. <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" term="嵌入式文件系统" label="嵌入式文件系统" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" term="嵌入式文件系统" label="嵌入式文件系统" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/flash/" term="flash" label="flash" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/jffs2/" term="jffs2" label="jffs2" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/yaffs2/" term="yaffs2" label="yaffs2" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/ubifs/" term="ubifs" label="ubifs" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 人工势场法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E4%BA%BA%E5%B7%A5%E5%8A%BF%E5%9C%BA%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E4%BA%BA%E5%B7%A5%E5%8A%BF%E5%9C%BA%E6%B3%95/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-04T10:02:06+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[人工势场法，即Artificial Potential Field，最早于20世纪80年代中期，由Khatib和Krogh提出的一种虚拟力法，其基本思想是将机器人在环境中的运动视为一种虚拟……]]></summary>
            
                <content type="html"><![CDATA[<p>人工势场法，即Artificial Potential Field，最早于20世纪80年代中期，由Khatib和Krogh提出的一种虚拟力法，其基本思想是将机器人在环境中的运动视为一种虚拟的人工受力场中的运动，其中障碍物对机器人产生斥力，而目标点对机器人产生引力，引力和斥力的合力作为机器人的加速力来控制机器人的运动方向和计算机器人的位置。</p>
<p>人工势场法具有结构简单、易于理解、便于实现实时控制的优点。其缺点也非常明显，比较容易陷入局部极小值问题，即机器人受到的合力为零，机器人停止运动，但却没有到达目标位置，陷入局部极小值。对于编队机器人数量比较大或者编队处于复杂环境中时，极小值问题显得尤为突出。此外，应用人工势场法的主要工作在于势函数的设计，对于未知环境中无法得知障碍物的尺寸、形状，这使得很难选取合理的势场点，进而很难设计出良好的势函数。基于这个原因，目前人工势场法主要用于全局环境已知情况下的多机器人编队。</p>
<p>下图中包括多机器人，障碍物和目标物，目标位置势场最低，即其虚拟重力势能是最小的,机器人的最初处于较高的位置因此具有较大的重力势能，环境中的障碍物可以看成为重力场中的凸点,因此机器人由于重力势能从初始位置运动到目标位置的过程可以看成<strong>从高处向低处</strong>运动的物体。环境中虚拟的势场用等势线的形式表现出来，即图中的密集分布的曲线上的势场都是相等的。因此容易得到如果机器人的运动模型是<strong>完整约束</strong>的，则机器人的理想运动曲线应该是<strong>垂直于所有的等势线</strong>的。然而因为机器人模型和障碍物形状的不规则，使得势场法在实际应用中存在一定的缺陷<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200405135443.png" alt=""></p>
<p>机器人群集的基本特征：避障避碰、速度匹配和群集中心。相对的，在多机器人群集势场包含三个基本特征，因此可设$U_{obstacle}(q)$为障碍物产生的势场,$U_{neighbor}(q)$为群集中周围邻域的机器人产生的势场，$U_{centre}(q)$为群集中心产生的势场，另外群集运动目标产生的势场为$U_{goal}(q)$，其中q表示机器人的当前位置。进行势场叠加后可得：</p>
<div>
$$
U_{\Sigma}(q)=\underbrace{U_{\text {goal }}(q)+U_{\text {centre }}(q)}_{\text {引力势场 }}+\underbrace{\sum U_{\text {obstacles }}(q)}_{\text {斥力势场 }}+\underbrace{\sum U_{\text {neighbors }}(q)}_{\text {引力/斥力同时存在 }}\\
F(q) = -\nabla U_{\Sigma}(q)
$$
</div>
$U_{\Sigma}(q)$表示机器人在环境中$q$位置时的综合势场，$F(q)$则表示势场中的势场力，方向沿势场的负梯度方向。
<p>在通常情况下，对于机器人而言环境地图一般都是未知的，常用的策略是传感器对环境进行实时感知并获得局部的位置信息，以进行决策，因此基于这种反应式的势场反馈导航原理如下图所示：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200405140801.png" alt=""></p>
<h3 id="目标势场和障碍物势场">目标势场和障碍物势场</h3>
<p>目标势场体现一种全局的引力效应，即势场存在于环境中一切位置，表现出来的特性为机器人离目标点越远，引力越大，按照这种规律可以建立目标势场函数：</p>
<div>
$$
\left\{\begin{array}{ll}
U_{goal}(x) = \frac{1}{2}k(x-x_{goal})^2\\
F_{goal}(x) = -k\|x-x_{goal}\|
\end{array}\right.
$$
</div>
其中$x_{goal}$为目标点位置，$x$为机器人的实时位置。因此目标点的引力势场通常是基于全局地图的，即机器人和目标点在全局地图中的位置己知，或者机器人
与目标点的相互关系己知为前提。
<p>相对的，障碍物势场为局部排斥力效应，即当且仅当机器人与障碍物之间的距离小于某定值时，才会有斥力势场的存在，而通常情况下要建立具有障碍物的环境地图，尤其是当环境中的障碍物变化的时候，全局地图的建立比较困难，通常采用基于外部传感器的反应式避障。设$f(x)$为当机器人处于$x$位置时激光探测距离，常数$d$为斥力场范围,因此当$f(x)&lt;d$时机器人将受到斥力场的作用。</p>
<div>
$$
\left\{\begin{array}{ll}
U_{\text {obs }}(x)=\left\{\begin{array}{ll}
\frac{\eta}{2}\left(\frac{1}{f(x)}-\frac{1}{d}\right)^{2} & f(x) \leq d \\
0 & f(x)>d
\end{array}\right. \\
F_{\text {obs }}(x)=\left\{\begin{array}{ll}
\|\left(\frac{1}{f(x)}-\frac{1}{d}\right) \frac{\eta \cdot \partial f}{f^{2} \cdot \partial x} \| & f(x) \leq d \\
0 & f(x)>d
\end{array}\right.
\end{array}\right.
$$
</div>
<h3 id="邻域机器人势场">邻域机器人势场</h3>
<p>借用物理学中对微小粒子（如分子，原子）的引力和斥力的关系，来描述邻域机器人的势场规律。假设机器人$i$与$j$相邻，则$i$相对$j$的势场函数和势场力函数分别为：</p>
<div>
$$
\left\{\begin{array}{l}
U_{n e i g}\left(x_{i} | x_{j}\right)=\frac{\mu}{2} \ln ^{2} \frac{\left\|x_{i}-x_{j}\right\|}{\delta}=\frac{\mu}{2} \ln ^{2} \frac{\left\|r_{i j}\right\|}{\delta} \\
F_{\text {neig }}\left(x_{i} | x_{j}\right)=-\frac{\mu \cdot \delta}{\left(x_{i}-x_{j}\right)} \cdot \ln \frac{|| x_{i}-x_{j} \|}{\delta}=-\frac{\mu \cdot \delta}{r_{i j}} \cdot \ln \frac{\left\|r_{i j}\right\|}{\delta}
\end{array}\right.
$$
</div>
可以得到该势场函数和势场力函数对应的曲线：
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200405142530.png" alt=""></p>
<h3 id="群集中心势场">群集中心势场</h3>
<p>在群集中除了目标点、障碍物以及邻域机器人这些可见的势场源外，还存在一种无形的吸引势场使得机器人朝某群集中心聚拢，该势场就是群集中心产生的
势场。首先群集中心本来就是一个非实体的概念，一般将群体的几何中心作为机
器人的群集中心，这样可以缩短机器人聚拢的距离，因此如果设群集中机器人的
个数为$M$个，则群集的几何中心为：</p>
<div>
$$
\bar{x}=\sum_{1}^{M} x_{j} / M
$$
</div>
由于同为引力场，所以类似目标点的势场函数规律可得群集中心的势场和势场力满足：
<div>
$$
\left\{\begin{array}{ll}
U_{centre}(x) = \frac{1}{2}c\|x-\bar{x})^2\| \\
F_{centre}(x) = -c(x-\bar{x})
\end{array}\right.
$$
</div>
<!--省略了部分-->
<h3 id="参考文献">参考文献</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>刘磊. 多移动机器人编队及协调控制研究[D]. 华中科技大学, 2009. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 基于图论的方法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E8%AE%BA%E7%9A%84%E6%96%B9%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E8%AE%BA%E7%9A%84%E6%96%B9%E6%B3%95/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-04T10:00:47+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[基于图论的方法研究多机器人编队，需要将队形信息转换成各种图，依靠图论知识及李雅普诺夫方法分析编队的稳定性，得出队形的控制策略。该方法中机器人编队队形是依据图论理论中图的……]]></summary>
            
                <content type="html"><![CDATA[<p>基于图论的方法研究多机器人编队，需要将队形信息转换成各种图，依靠图论知识及李雅普诺夫方法分析编队的稳定性，得出队形的控制策略。该方法中机器人编队队形是依据图论理论中图的节点与边的关系来描述。节点即表示机器人的运动学特性，即是对运动方式的描述，而边则表示机器人之间的关系，是对运动的约束，利巧相应的图论知识与控制理论知识研究编队队形控制输出具有一致性。基于图论法的优点在于图的形状可任意变化，队形描述也相对简单，编队中改变队形较容易，并且图论的相关理论研究比较成熟，但不足之处在于物理实现比较复杂，通常只能适用于仿真环境的理论研究<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p>用图论的方法描述车辆编队，这种表示方法能够唯一的（无二义性的）定义多车辆编队队形，准确反映出编队中各车辆间的相互作用关系。车辆队表示为图$G=(V,E)$，其中，V 表示图的结点集，代表车辆集$V={1,2,...,N_a}$ } ； E 表示图的边集，其中的边元素是相关车辆 $i,j\in V$ 间的一个有序数对$(i,j)\in E$，表示车辆间的连接关系，对于有$N_a$个车辆的系统，至少用$M=N_a-1$个向量就可以对车辆编队进行唯一描述。编队图被认为是无方向的，所以$(i,j)\in E,(j,i)\in E$，如$(i,j)\in E$，那么车辆 i 和 j就被称为相邻车辆，车辆$i$的相邻车辆集表示为$N_i\in V$。另外，为了保证车辆编队沿给定的路径运行，所以将编队中与寻径相关的车辆定义为核心车辆。尽管在编队中任意两个核心车辆之间可能没有相关向量，但我们认为核心车辆间均为相邻车辆关系，因为它们之间通过寻径目标耦合<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>两相邻车辆$i $和$j$间的期望相关向量表示为$d_{ij}\in R^n$，它表示处于期望编队路径位置时，两相邻车辆间的距离。</p>
<p>给定了编队图$G=(V,E)$和编队路径$q_{ref}$后，就可以定义出编队向量$F=(f_1,...,f_{M+1})\in R^{n(M+1)}$它的分量$f_1\in R^n$定义如下：</p>
<div>
$$
f_l = q_i-q_j+d_{ij},\forall l=1,...,M\\
f_{M+1}=q_{\Sigma}-q_d
$$
</div>
其中$i$表示构成边$e_l$的尾结点，$j$表示构成边$e_l$的头结点。$q_{\Sigma}$表示当前车辆的几何中心，$q_d$表示期望的车辆几何中心。很明显，当$F\equiv 0$时车辆组成编队，得到从$q$到$F$的映射关系：
<div>
$$
F=Gq+\hat{d}, G^T=[C_{(n)}\quad V]\\
\hat{d}=(...,d_{ij},...,-q_d)\\
V^T=[V_1...V_{N_a}]\in R^{n\times n\times N_a}
$$
</div>
$V_i\in R^{n\times n}$定义如下，
<div>
$$
Vi=\left\{\begin{array}{ll}
\frac{1}{N_a}I_{(n)} \quad if \quad i=1,2,...,N_a\\
0\quad otherwise
\end{array}\right.
$$
</div>
矩阵$C_{n}\in R^{n(N_a\times M)}$与关联矩阵$C\in R^{N_a\times M}$有关，其中$C=[c_{ij}]$的元素根据边集$E$的元素定义如下，
<div>
$$
c_{ij} = \left\{\begin{array}{ll}
+1, i为尾结点\\
-1,i为头节点\\
0,其它
\end{array}\right.
$$
</div>
根据以上的定义，当$G_{q^c}=-\hat{q}$ 时就能够计算出每个车辆的期望运行轨线。
<h3 id="参考文献">参考文献</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>岑斌斌. 多机器人编队的分布式协同控制方法研究[D]. 南京大学, 2015. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>贺晨龙, 黄丽湘, 张继业. 多车辆编队协作控制[C]// 全国非线性振动、全国非线性动力学和运动稳定性学术会议. 2007. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 基于行为的方法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%96%B9%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%96%B9%E6%B3%95/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-04T09:11:07+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[基于行为的方法的主要思想是将编队任务转换为一系列具有特定功能的基本运动行为，这些基本运动行为是机器人运动的最小运动单位，例如，向左转、前进、奔向目标、姿态调整、蔽障、沿……]]></summary>
            
                <content type="html"><![CDATA[<p>基于行为的方法的主要思想是将编队任务转换为一系列具有特定功能的基本运动行为，这些基本运动行为是机器人运动的最小运动单位，例如，向左转、前进、奔向目标、姿态调整、蔽障、沿墙运动、目标导航等等。基于行为的方法通常由两部分组成，分别是基本<strong>行为设计</strong>部分和<strong>行为选择</strong>设计部分。对编队中的每个机器人而言，机器人的输入可以是自身传感器的探测信息，也可以是通过通信获取编队中其它某个或者多个机器人的行为输出，行为选择设计部分根据机器人输入信息使得机器人选择对应的基本行为（以一定角速度和线速度的方式）进行输出，从而使得机器人处于编队中理想的位置<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，具体如下图所示：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200404112052576.png" alt=""></p>
<p>基于行为方法的编队控制包括以下三种控制方法<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<ol>
<li>行为抑制法：首先对每个行为进行优先级排序，这样当无人车需要同时执行多个行为时，无人车就会按照优先级顺序执行优先级最高的行为。</li>
<li>加权平均法：首先对每个行为规定一个对应的权值，根据对应行为的重要程度设置对应的权值。这样当无人车需要同时执行多个行为时，无人车会计算所有行为的加权求和，得到的结果经过正则化后作为无人车的行为控制；</li>
<li>模糊逻辑法：当无人车需要同时执行多个行为时，通过查看模糊规则表，执行相对的行为控制。</li>
</ol>
<p>基于行为的方法是一种分布式的控制方法，该方法具有柔性好的特点，能够在编队中动态的添加或者减少机器人的数量，同时该方法使得机器人表现出一定的智能性，类似于人或者其它高等动物的感官反应或者决策思维，更容易被人们所理解和认识。其缺点是难以设计出合适的运动行为以及难以对系统进行数据建模和系统稳定性分析，由于缺乏相关数学理论，对于设计的运动行为会对编队的稳定性造成什么影响目前仍然无法得知，只能通过实践证明，同时，在复杂环境下的机器人的输出行为是难以预见的，这使得该方法的灵活性不高。目前该方法主要运用于较大规模的编队队形、跟踪、空中多飞行器编队、包围入侵者、大面积区域搜索等。</p>
<h3 id="基于位姿误差的机器人编队基本运动行为设计3">基于位姿误差的机器人编队基本运动行为设计<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></h3>
<h4 id="机器人运动学模型">机器人运动学模型</h4>
<p>二维空间机器人位置和姿态表示为：</p>
<div>
$$
q_0=[x_0\quad y_0\quad \theta_0]^T
$$
</div>
假设机器人当前的线速度$v_0$和角速度$\omega_0$，可得移动机器人的位姿$\dot{q}$：
<div>
$$
\dot{\boldsymbol{q}}_{0}=\left[\begin{array}{c}
\dot{x}_{0} \\
\dot{y}_{0} \\
\dot{\theta}_{0}
\end{array}\right]=\left[\begin{array}{cc}
\cos \theta_{0} & 0 \\
\sin \theta_{0} & 0 \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
v_{0} \\
\omega_{0}
\end{array}\right]
$$
</div>
#### 位姿误差描述
<p>虚拟结构仅被用以描述<strong>目标编队的形状</strong>和编队中虚拟机器人的固定位置，而<strong>非限制该位置上真实存在的机器人</strong>。如下图所示：机器人团队由领航者$q_L(x_L,y_L,\theta_L)$和跟随者$q_{F2}(x_{F2},y_{F2},\theta_{F2})$、$q_{F3}(x_{F3},y_{F3},\theta_{F3})$组成。虚线空心图形表示编队中的虚拟机器人，即跟随者$q_{F2}$和$q_{F3}$和应当抵达的位置，表示为$q_{T2}(x_{T2},y_{T2},\theta_{T2})$、$q_{T3}(x_{T3},y_{T3},\theta_{T3})$。$q_L$与$q_{T2}$、$q_{T3}$共同组成虚拟的三角形编队。设计的行为应该能够确保跟随者$q_{F2}$和$q_{F3}$到达编队中$q_{T2}$、$q_{T3}$的位置。那么可以通过$q_{F2}$和$q_{T2}$之间的位置关系描述位姿误差。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200404142240713.png" alt=""></p>
<p>最终通过公式推导可以得到：</p>
<div>
$$
\boldsymbol{e}_{FiTj}=\left[\begin{array}{c}
e_{FiTj}^{x} \\
e_{FiTj}^{y} \\
e_{FiTj}^{\theta}
\end{array}\right]=\left[\begin{array}{ccc}
\cos \theta_{F i} & \sin \theta_{F i} & 0 \\
-\sin \theta_{F i} & \cos \theta_{F i} & 0 \\
0 & 0 & 1
\end{array}\right]\left(\boldsymbol{q}_{T j}-\boldsymbol{q}_{F i}\right), i, j \in[2, n]
$$
</div>
上式中，$\bold{q}_{Tj}$为通过传感器或通信获取的虚拟目标机器人的位姿，$\bold{q}_{Fi}$为机器人自身的位姿信息，主要通过如GPS、编码器等传感器获得。为了使$\bold{e}_{FiTj}$处于一定的阈值内，设计了两种基本运动行为与作为基本运动行为的选择依据的三种描述性行为。两种基本行为是直线运动与旋转运动。设计的思想是首先机器人采用旋转运动面向目标，然后采用直线运动奔向目标，最后通过旋转和目标完全重合，此时机器人到达编队中虚拟机器人的位置。当所有机器人均完成此任务时，编队形成。上述思想可以归纳为转向目标，奔向目标与姿态调整三种描述性行为。
<p>令阈值为：$\boldsymbol{\delta} = [\delta_p\quad \delta_p\quad \delta_o]^T$，$\delta_p$表示位置误差常数，$\delta_o$表示姿态角度误差常数，$T$为实际需要的有限时间。</p>
<h4 id="行为选择">行为选择</h4>
<ul>
<li>转向目标</li>
</ul>
<p>当机器人与虚拟目标之间的$y$方向误差$|e^y_{FiTj}|&gt;\delta_p$，时，虚拟机器人$q_{Tj}$在跟随机器人$q_{Fi}$运动的正前方的时候，机器人选择奔向目标的行为。该行为同时考虑了当$q_{Fi}$背离$q_{Tj}$且两者在同一直线上的情况，此时$|e^y_{FiTj}|&lt;\delta_p,e^x_{FiTj}&lt;0$。该行为的触发条件：</p>
<div>
$$
\bigcup\left\{\begin{array}{l}
\left|e_{F i T j}^{y}\right| \geq \delta_{p} \\
e_{F i T j}^{x}<-\delta_{p}\left(\left|e_{FiTj}^{y}\right|<\delta_{p}\right) i, j \in[2, n]
\end{array}\right.
$$
</div>
转向目标行为的结束条件为：
<div>
$$
\lim _{t \rightarrow t_{F i T j}^{T T}}\left|e_{F i T j}^{y}(t)\right|<\delta_{P}, \quad e_{F i T j}^{x} \geq \delta_{P}, i, j \in[2, n]
$$
</div>
<ul>
<li>奔向目标</li>
</ul>
<p>当虚拟机器人$q_{Tj}$在跟随机器人$q_{Fi}$运动的正前方，即$|e^y_{FiTj}|&lt;\delta_p$时，机器人选择奔向目标的行为。奔向目标行为用于缩短虚拟机器人$q_{Tj}$与跟随机器人$q_{Fi}$之间的直线距离。该行为的触发条件：</p>
<div>
$$
|e^y_{FiTj}|<\delta_p, |e^x_{FiTj}|\geq\delta_p, i,j\in[2,n].
$$
</div>
奔向目标行为的结束条件为：
<div>
$$
|e^y_{FiTj}|<\delta_p, \lim _{t \rightarrow t_{F i T j}^{T T}}|e^x_{FiTj}|(t)<\delta_p, i,j\in[2,n].
$$
</div>
<ul>
<li>姿态调整</li>
</ul>
<p>当虚拟机器人$q_{Tj}$与跟随机器人$q_{Fi}$之间的距离误差分量$|e^x_{FiTj}|&lt;\delta_p$，$|e^y_{FiTj}|&lt;\delta_p$，且两者方向误差值$|e^\theta_{FiTj}|&gt;\delta_o$的时候，机器人选择姿态调整行为。姿态调整行为是为了让近似处于同一点上的$q_{Tj}$与$q_{Fi}$完成角度的重合。该行为的触发条件：</p>
<div>
$$
|e^x_{FiTj}|<\delta_p, |e^y_{FiTj}|<\delta_p, |e^\theta_{FiTj}|\geq\delta_o,i,j\in[2,n].
$$
</div>
姿态调整行为的结束条件为：
<div>
$$
|e^x_{FiTj}|<\delta_p, |e^y_{FiTj}|<\delta_p, \lim _{t \rightarrow t_{F i T j}^{T T}}|e^\theta_{FiTj}|(t)<\delta_o,i,j\in[2,n].
$$
</div>
<h3 id="参考文献">参考文献</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>陈传均. 多机器人领航—跟随型编队控制研究[D]. 杭州电子科技大学. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>王京.多智能体系统编队避障算法研究[D].上海:华东理工大学,2013. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>刘磊. 多移动机器人编队及协调控制研究[D]. 华中科技大学, 2009. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">c语言运算符</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/c/%E8%BF%90%E7%AE%97%E7%AC%A6/" />
            <id>https://chengshuyi.github.io/posts/c/%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-03T17:25:34+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[本文主要汇总了c语言的一些运算符，因此我们能对运算符有全局的认识。 运算符 名称 算术运算符 +, -, *, /, % 移位运算符 &gt;&gt;, &lt;&lt; 位运算符 &amp;, |, ^ 赋值运算符 = 复合赋值运算符 +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=……]]></summary>
            
                <content type="html"><![CDATA[<p>本文主要汇总了c语言的一些运算符，因此我们能对运算符有全局的认识。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">算术运算符</td>
<td align="center"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></td>
</tr>
<tr>
<td align="center">移位运算符</td>
<td align="center"><code>&gt;&gt;</code>, <code>&lt;&lt;</code></td>
</tr>
<tr>
<td align="center">位运算符</td>
<td align="center"><code>&amp;</code>, <code>|</code>, <code>^</code></td>
</tr>
<tr>
<td align="center">赋值运算符</td>
<td align="center"><code>=</code></td>
</tr>
<tr>
<td align="center">复合赋值运算符</td>
<td align="center"><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code></td>
</tr>
<tr>
<td align="center">单目运算符</td>
<td align="center"><code>!</code>, <code>++</code>, <code>-</code>, <code>&amp;</code>, <code>sizeof</code>, <code>~</code>, <code>--</code>, <code>+</code>, <code>*</code>, <code>强制类型转换</code></td>
</tr>
<tr>
<td align="center">关系运算符</td>
<td align="center"><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code>, <code>==</code></td>
</tr>
<tr>
<td align="center">逻辑运算符</td>
<td align="center"><code>&amp;&amp;</code>, <code>||</code></td>
</tr>
<tr>
<td align="center">条件运算符</td>
<td align="center"><code>a?b:c</code></td>
</tr>
<tr>
<td align="center">逗号运算符</td>
<td align="center"><code>,</code></td>
</tr>
<tr>
<td align="center">下标运算符</td>
<td align="center"><code>[]</code></td>
</tr>
<tr>
<td align="center">函数运算符</td>
<td align="center"><code>()</code></td>
</tr>
<tr>
<td align="center">结构成员运算符</td>
<td align="center"><code>.</code>, <code>-&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="算术运算符">算术运算符</h3>
<p>算术运算符包括：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>，它们也都是双目运算符。</p>
<blockquote>
<p>注意同单目运算符中的<code>+</code>, <code>-</code>, <code>*</code>区分开来，算术运算符时双目运算符，所以使用它们时并不会造成语义上的歧义。</p>
</blockquote>
<h3 id="--移位运算符--"><!--移位运算符--></h3>
<!--`>>`, `<<`-->
<h3 id="--位运算符--"><!--位运算符--></h3>
  <!--`&`, `|`, `^`-->
<h3 id="--赋值运算符--"><!--赋值运算符--></h3>
<!--`=`-->
<!--复合赋值运算符：`+= -= *= /= %= <<= >>= &= ^= |=-->`
<h3 id="单目运算符">单目运算符</h3>
<p>单目运算符包括：<code>!</code>, <code>++</code>, <code>-</code>, <code>&amp;</code>, <code>sizeof</code>, <code>~</code>, <code>--</code>, <code>+</code>, <code>*</code>, <code>强制类型转换</code></p>
<ul>
<li>
<p>经过<code>!</code>的数值只有两种结果：
$$
!a=\left{\begin{array}{cc}
0,a\neq0 \<br>
1,a=0
\end{array}\right.
$$</p>
</li>
<li>
<p><code>~</code>会对所有的位取反，包括符号位：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">~</span><span class="n">a</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//-1
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>sizeof</code>的参数可以是数组、指针、类型、对象、函数等，其作用是计算静态对象的内存大小；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// sizeof的宏定义原型：#define sizeof(L_Value) ((char*)(&amp;L_Value + 1) - (char*)(&amp;L_Value))
</span><span class="c1"></span>  
<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">a_ptr</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">a_ptr</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a_ptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 
    <span class="c1">//这里可以看出数组和指针并非完全相等，编译器对其处理的方式还是不同的。
</span><span class="c1"></span>    <span class="c1">//0x62fdb0 0x62fdb0
</span><span class="c1"></span>    <span class="c1">//100 8
</span><span class="c1"></span><span class="p">}</span>
  
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="--关系运算符--"><!--关系运算符--></h3>
<!--`> >= < <= != ==-->`
<h3 id="--逻辑运算符--"><!--逻辑运算符--></h3>
<!--`&& ||`-->
<h3 id="--条件运算符--"><!--条件运算符--></h3>
<!--?;-->
<h3 id="--逗号运算符--"><!--逗号运算符--></h3>
<!--都好运算符将多个表达式分隔开来，这些表达式自左向右逐个进行求值-->
<h3 id="--下标运算符--"><!--下标运算符--></h3>
<!--[]-->
<h3 id="--函数运算符--"><!--函数运算符--></h3>
<!--()-->
<h3 id="--结构成员运算符--"><!--结构成员运算符--></h3>
<!--`.` ->-->
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/c%E8%AF%AD%E8%A8%80/" term="c语言" label="c语言" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/c%E8%AF%AD%E8%A8%80/" term="c语言" label="c语言" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/" term="c语言运算符" label="c语言运算符" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">伙伴系统</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-03T15:26:04+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[伙伴算法是一种动态存储分配算法，用于实现操作系统内核空间和用户空间 (如 C 语言库) 的分配和回收操作.。Knowlton和 Knuth最早系统地描述了用于内存管理中的二分伙伴……]]></summary>
            
                <content type="html"><![CDATA[<p>伙伴算法是一种动态存储分配算法，用于实现操作系统内核空间和用户空间 (如 C 语言库) 的分配和回收操作.。Knowlton和 Knuth最早系统地描述了用于内存管理中的二分伙伴算法。之后，Hirschberg和Shen先后提出斐波那契伙伴算法和加权伙伴算法，作为伙伴算法的两种变体。为了适应不同的内存请求概率分布，Peterson又进一步提出泛化伙伴算法，针对不同请求概率分布采取不同的分配策略。为了追求时间效率，Linux 内核选择实现了二分伙伴算法, 该算法的优点在于伙伴地址的计算更加简便、高效<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p>Linux内核伙伴系统算法把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续页框的页框块。最大可以申请1024个连续页框，也即4MB大小的连续空间。假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了即将页框分为两个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>下图是伙伴系统只有0阶和2阶内存块时的分配情况。</p>
<p><img src="../../../static/img/image-20200403231746644.png" alt="image-20200403231746644"></p>
<p>本文首先介绍了linux内存区域的概念，然后详细描述了伙伴系统算法中分配算法和回收算法，最后简要的描述了伙伴系统算法在分配时区域的选择。</p>
<h3 id="内存区域">内存区域</h3>
<p>UMA（Uniform-Memory-Access）模型：物理存储器被所有处理机均匀共享。所有处理机对所有存储字具有相同的存取时间，这就是为什么称它为均匀存储器存取的原因。每台处理机可以有私用高速缓存,外围设备也以一定形式共享。</p>
<p>NUMA（Non-Uniform-Memory-Access）模型：NUMA模式下，处理器被划分成多个&quot;节点&quot;（node）， 每个节点被分配有的本地存储器空间。 所有节点中的处理器都可以访问全部的系统物理存储器，但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多。</p>
<p>UMA可以看成NUMA特例。下图是内存区域管理结构，<code>pg_data_t</code>代表着一个节点，<code>zones</code>存储着每个内存区域的物理页的数据结构<code>struct page</code>。</p>
<p><img src="../../../static/img/image-20200403225121981.png" alt="image-20200403225121981"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">pglist_data</span> <span class="p">{</span> 
    <span class="k">struct</span> <span class="n">zone</span> <span class="n">node_zones</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span> 	<span class="c1">//内存分区，ZONE_DMA, ZONE_NORMAL, ZONE_HIGHMEM
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zonelist</span> <span class="n">node_zonelists</span><span class="p">[</span><span class="n">MAX_ZONELISTS</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">nr_zones</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">node_mem_map</span><span class="p">;</span> 				<span class="c1">//该节点物理内存中每一页的页框描述符
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_start_pfn</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_present_pages</span><span class="p">;</span>  
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_spanned_pages</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">node_id</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">pgdat_next</span><span class="p">;</span> 
    <span class="n">wait_queue_head_t</span> <span class="n">kswapd_wait</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kswapd</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">kswapd_max_order</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">pg_data_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在内存中，每个node又被分成的区，它们各自描述在内存中的范围。一个管理区(zone)由<code>struct zone</code>结构体来描述，下面是可能分区的情况：</p>
<ol>
<li>ZONE_DMA标记适合DMA的内存域。该区域的长度依赖于处理器类型。在IA-32计算机上，一般的限制是16 MiB，这是由古老的ISA设备强加的边界，因此现代的计算机也可能受这一限制的影响。</li>
<li>ZONE_DMA32标记了使用32位地址字可寻址、适合DMA的内存域。显然，只有在64位系统上，两种DMA内存域才有差别。在32位计算机上，本内存域是空的，即长度为0 MiB。在Alpha和AMD64系统上，该内存域的长度可能从0到4 GiB。</li>
<li>ZONE_NORMAL标记了可直接映射到内核段的普通内存域。这是在所有体系结构上保证都会存在的唯一内存域，但无法保证该地址范围对应了实际的物理内存。例如，如果AMD64系统有2 GiB内存，那么所有内存都属于ZONE_DMA32范围，而ZONE_NORMAL则为空。</li>
<li>ZONE_HIGHMEM标记了超出内核段的物理内存，对应着IA-32计算机上896MB以上的物理内存。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">zone</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_min</span><span class="p">,</span> <span class="n">pages_low</span><span class="p">,</span> <span class="n">pages_high</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lowmem_reserve</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span> 
    <span class="k">struct</span> <span class="n">per_cpu_pageset</span> <span class="n">pageset</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span> 
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">free_area</span> <span class="n">free_area</span><span class="p">[</span><span class="n">MAX_ORDER</span><span class="p">];</span>	<span class="c1">//伙伴系统算法
</span><span class="c1"></span>    <span class="n">ZONE_PADDING</span><span class="p">(</span><span class="n">_pad1_</span><span class="p">)</span> 
    <span class="cm">/* 通常由页面收回扫描程序访问的字段 */</span> 
    <span class="n">spinlock_t</span> <span class="n">lru_lock</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">active_list</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">inactive_list</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scan_active</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scan_inactive</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_scanned</span><span class="p">;</span> <span class="cm">/* 上一次回收以来扫描过的页 */</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 内存域标志，见下文 */</span> 
    <span class="cm">/* 内存域统计量 */</span> 
    <span class="n">atomic_long_t</span> <span class="n">vm_stat</span><span class="p">[</span><span class="n">NR_VM_ZONE_STAT_ITEMS</span><span class="p">];</span> 
    <span class="kt">int</span> <span class="n">prev_priority</span><span class="p">;</span> 
    <span class="n">ZONE_PADDING</span><span class="p">(</span><span class="n">_pad2_</span><span class="p">)</span> 
    <span class="cm">/* 很少使用或大多数情况下只读的字段 */</span> 
    <span class="n">wait_queue_head_t</span> <span class="o">*</span> <span class="n">wait_table</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_hash_nr_entries</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_bits</span><span class="p">;</span> 
    <span class="cm">/* 支持不连续内存模型的字段。 */</span> 
    <span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">zone_pgdat</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_start_pfn</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spanned_pages</span><span class="p">;</span> <span class="cm">/* 总长度，包含空洞 */</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">present_pages</span><span class="p">;</span> <span class="cm">/* 内存数量（除去空洞） */</span> 
    <span class="cm">/* 
</span><span class="cm">    * 很少使用的字段：
</span><span class="cm">    */</span> 
     <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_maxaligned_in_smp</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">free_area</span> <span class="p">{</span> 
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_list</span><span class="p">[</span><span class="n">MIGRATE_TYPES</span><span class="p">];</span> 	<span class="c1">//反内存碎片机制
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_free</span><span class="p">;</span> 						
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="分配算法">分配算法</h3>
<p>当内核请求分配内存时，伙伴系统执行分配算法以满足其需求。分配算法的基本思想是寻找能够满足内核需求的最小空闲内存块，如果该内存块的阶大于内核请求的阶，则将其逐步划分为一系列低阶内存块，直到划分出恰好满足需求的一个内存块，并分配给内核使用。其余低阶内存块按其所属的阶被依次插入相应的空闲链表，用于满足今后的内存请求。</p>
<p>假设当前内存的分布情况如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">free_area</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">nr_free</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">free_area</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">nr_free</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">free_area</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">nr_free</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>内核请求分配一个1 阶空闲内存块，对于 free_area 数组的查找将从 1 阶开始。由于 1 阶的空闲链表为空，因此继续查找高阶空闲链表，直到发现 3 阶空闲链表非空，查找结果为 3，这说明存在一个 3 阶的空闲内存块可供分配。然后，从 3 阶空闲链表移除第一个内存块的首页描述符，并用 page 指针指向它。同时计算 <code>free_area[3].nr_free--</code>。</p>
<p>由于找到的空闲内存块的尺寸 (3 阶) 超过了内核请求的尺寸 (1 阶)，因此需要划分.。首先将其等分为<strong>两个（二分伙伴算法的名字来源）</strong> 2 阶内存块, 其中高地址端一块的首页描述符指针为 <code>page + 4</code>，将其插入2阶空闲链表，并计算<code>free_area[2].nr_free++</code>。然后，进一步划分低地址端的另一个2阶内存块，将其等分为两个1阶内存块。高地址端一块的首页描述符指针为<code>page+2</code>，将其插入1阶空闲链表，并计算<code>free_area[1].nr_free++</code>。剩下低地址端的一块1阶内存块恰好满足内核的需求，因此停止划分。</p>
<h3 id="回收算法">回收算法</h3>
<p>伙伴系统回收算法的基本思想是首先确定待回收内存块的伙伴，如果伙伴是空闲的，则将二者合并为一个高阶空闲内存块。重复上述合并过程, 直至伙伴不再空闲或合并形成的空闲内存块达到最高阶。在上述过程中，每次合并前都要将伙伴从其所在的空闲链表中移除。合并完成后，最终形成的高阶空闲内存块被插入相应空闲链表的表头。不难看出，回收算法的一项重要的工作是确定待回收内存块的伙伴：</p>
<p>两个内存块互为伙伴 (Buddy) 当且仅当满足以下三个条件：</p>
<ol>
<li>二者在内存中<strong>相邻</strong>且不重叠；</li>
<li>二者具有<strong>相同的阶</strong>；</li>
<li>假设二者的阶都为k，则合并后形成一个k+1阶空闲内存块。</li>
</ol>
<p>我们知道linux采用数组的方式维护每一个物理页的数据结构<code>struct page</code>，即<code>mem_map</code>。所以通过<code>mem_map[page_addr&gt;&gt;12]</code>可以获得某物理页的<code>struct page</code>。该结构中包含了该页是否为空闲的状态。所以可以通过<code>mem_map[(page_addr&gt;&gt;12)-2^k]</code>确定左伙伴是否为空闲；通过<code>mem_map[(page_addr&gt;&gt;12)+2^k]</code>确定右伙伴是否为空闲。</p>
<h4 id="分配区域的选择">分配区域的选择</h4>
<p>我们知道Linux内存分为结点，在结点内部分为区域，每一个区域由伙伴系统算法管理。伙伴系统算法在分配时首先会考虑当前结点是否有充足的内存，其次才会考虑从其它结点借用内存。节点内部分配的优先级从高到低依次是：ZONE_HIGHMEM、ZONE_NORMAL和ZONE_DMA。</p>
<h3 id="参考索引">参考索引</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>薛峰.Linux内核伙伴系统分析[J].计算机系统应用,2018,27(01):174-179. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="https://glemontree.github.io/2017/10/23/%5BLinux%5D%20Linux%E4%B8%AD%E7%9A%84%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%92%8Cslab%E6%9C%BA%E5%88%B6/">https://glemontree.github.io/2017/10/23/[Linux]%20Linux%E4%B8%AD%E7%9A%84%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%92%8Cslab%E6%9C%BA%E5%88%B6/</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" term="伙伴系统" label="伙伴系统" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 领航跟随法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E9%A2%86%E8%88%AA%E8%B7%9F%E9%9A%8F%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E9%A2%86%E8%88%AA%E8%B7%9F%E9%9A%8F%E6%B3%95/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-03T11:27:11+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[跟随者领航者法的基本思想是将编队控制问题转化为跟随者跟踪领航者的位置和方向的问题。在多机器人组成的群体中，某个机器人被指定为领航者，其余作为它的跟随者，跟随者以一定的距……]]></summary>
            
                <content type="html"><![CDATA[<p>跟随者领航者法的基本思想是将编队控制问题转化为跟随者跟踪领航者的位置和方向的问题。在多机器人组成的群体中，某个机器人被指定为领航者，其余作为它的跟随者，跟随者以一定的距离间隔跟踪领航机器人的位置和方向。</p>
<p>跟随者通过跟踪功能强大的领航者实现预期的目标，当领航者的位置等参量发生变化时，跟随者机器人通过比较这些参量的误差得到控制量并引导行为。对于跟随领航者法有两种控制器形式：$l-l$ 控制器和$l-\varphi$控制器。$l-\varphi$控制器的控制目标是使跟随者和领航者之间的距离和相对转角达到设定值。$l-l$控制器考虑的是三个机器人之间的相对位置问题。当跟随者和两个领航者之间的距离达到设定值的话，就可以认为整个队形稳定了<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p>这种方法的优点是比较容易实现编队控制。能够实现硬件资源的合理配置，减少了跟随机器人间的相互干扰，因为编队的所有轨迹均有领航者提供，同时跟随者只需跟随领航者运行，不需配置像领航者那样强大的传感器资源，只需配置满足任务需要的传感器即可。但是，这种方法采用的集中式控制使得编队的抗干扰能力较差，如果领航者受到破坏或者因为某种原因不能正常运行，整个编队的正常运行将不能得到保证，再者，所有跟随者都需要与领航者通信，使得领航者的通信负担重，使得这种方法不适用于跟随者较多的情形[^3]。</p>
<h3 id="建立模型2">建立模型<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h3>
<p>领航跟随编队控制算法可以分为两个部分: 一是确定领航者及队形。二是跟随者跟随领航者。第一部分比较容易实现，可以根据实际情况确定。第二部分比较复杂，是算法的重点。在上面模型中领航跟随法的控制也就是控制领航者和跟随者之间的间距 $l$ 与角度 $\varphi$。这种编队控制的主要思想是: 控制间距 $l$ 和角度 $\varphi$，使之与期望的间距 $l_d$和期望的角度 $\varphi_d$相等。使跟随机器人以角度 $\varphi$ 和间距 $l$ 跟踪领航机器人，从而形成编队。领航者只需要沿着预定规划的路径行走，跟随者需要知道领航者的位置坐标$( x_1，y_1)$ 、角度 $\theta_1$、速度 $v_1$、角速度 $\omega_1$及自身的位置坐标$( x_2，y_2)$ 、角度 $\theta_2$，通过计算确定自身的前进速度 $v_2$、角速度 $\omega_2$来完成编队控制。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200403130104645.png" alt=""></p>
<p>使用参考点的坐标来表示机器人描述中的坐标。机器人描述向量 $r_i= ( x_i，y_i，\theta_i，v_i，\omega_i) $描述机器人 $i$ 的位置坐标、角度、前进速度和角速度，则领航者机器人的描述向量为 $r_1= ( x_1，y_1，\theta_1，v_1，\omega_1)$ ，跟随机器人的描述向量为 $r_2= ( x_2，y_2，\theta_2，v_2，\omega_2)$ 。根据上图中的模型可以得出机器人描述向量各个量之间的关系:</p>
<div>
$$
\left\{\begin{array}{1}
\dot{x}=v_{i} \cos \theta_i \\
\dot{y}=v_{i} \sin \theta_i \\ 
\dot{\theta}_{i}=\omega_{i}
\end{array}\right.
$$
</div>
<blockquote>
<p>注：单位时间内位姿的变化量。</p>
</blockquote>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200403130200690.png" alt="image-20200403130200690"></p>
<p>根据上图的控制关系，跟随机器人的运动学方程为:</p>
<div>
$$
\left\{\begin{array}{l}
\dot{l}=v_{2} \cos \gamma-v_{1} \cos \varphi+d \omega_{2} \sin \gamma \\
\dot{\varphi}=\frac{1}{l}\left(v_{1} \sin \varphi-v_{2} \sin \gamma+d \omega_{2} \cos \gamma-l \omega_{1}\right) \\
\dot{\theta}_{2}=\omega_{2} \tag{2}
\end{array}\right.
$$
</div>
<p>其中 $γ = \varphi + \theta_1－ \theta_2$。</p>
<p>根据算法原理结合结构图的闭环特性可得:</p>
<div>
$$
\left\{\begin{array}{1}
\dot{l}=\alpha(l_d-l) \\
\dot{\varphi}=\beta(\varphi_d-\varphi)
\end{array}\right.\tag{3}
$$
</div>
<blockquote>
<p>通过控制使得$l$和$\varphi$逐渐达到期望值$l_d$和$\varphi_d$，最终$l$和$\varphi$单位时间内的变化量为0。</p>
</blockquote>
<p>式中的 $α，β$ 是闭环控制中的比例系数，联合(2) 式和(3) 式可得跟随机器人的速度$( v_2，\omega_2)$ ，即控制系统的输出：</p>
<div>
$$
\left\{\begin{array}{l}
\omega_{2}=\frac{\cos \gamma}{d}\left[\beta l\left(\varphi_{d}-\varphi\right)-v_{1} \sin \varphi+l \omega_{1}+p \sin \gamma\right] \\
v_{2}=p-d \omega_{2} \tan \gamma \tag{4}
\end{array}\right.
$$
</div>
其中$p=\frac{v_icos\varphi+\alpha(l_d-l)}{cos\gamma}$由( 4) 式得出跟随机器人的控制输入量$( v_2，\omega_2)$ 。根据上面结果输入跟随机器人的控制量来控制跟随机器人的前进速度与角速度，从而完成领航跟随编队控制算法的队形保持，实现编队控制。
<h3 id="参考文献">参考文献</h3>
<p>[] 陈传均. 多机器人领航—跟随型编队控制研究[D]. 杭州电子科技大学. ↩</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>胡玮韬.多机器人编队及运动控制研究[D].陕西:西安电子科技大学,2010. DOI:10.7666/d.y1668394. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>赵明, 林茂松, 黄玉清. Leader-following Formation Control of Multi-robots Based on Dynamic Value of $\varphi$%基于动态\varphi值的领航跟随法多机器人编队控制[J]. 西南科技大学学报, 2013, 028(004):57-61. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Slab分配器</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/slab/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/slab/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-02T16:24:50+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[在linux内核中伙伴系统用来管理物理内存，其分配的基本单位是页。由于伙伴系统分配的粒度又太大，因此linux采用slab分配器提供动态内存的管理功能，而且可以作为经常……]]></summary>
            
                <content type="html"><![CDATA[<p>在linux内核中伙伴系统用来管理物理内存，其分配的基本单位是页。由于伙伴系统分配的粒度又太大，因此linux采用slab分配器提供动态内存的管理功能，而且可以作为经常分配并释放的对象的高速缓存。slab分配器的优点：</p>
<ol>
<li>
<p>可以提供小块内存的分配支持，通用高速缓存可分配的大小从$2^5B$到$2^{25}B$，专用高速缓存没有大小限制；</p>
</li>
<li>
<p>不必每次申请释放都和伙伴系统打交道，提供了分配释放效率；</p>
</li>
<li>
<p>如果在slab缓存的话，其在CPU高速缓存的概率也会较高；</p>
</li>
<li>
<p>伙伴系统对系统的数据和指令高速缓存有影响，slab分配器采用着色降低了这种副作用。</p>
</li>
</ol>
<p>伙伴系统分配的内存大小是页的倍数，不利于CPU的高速缓存：如果每次都将数据存放到从伙伴系统分配的页开始的位置会使得高速缓存的有的行被过度使用，而有的行几乎从不被使用**[cpu的L1 cache一般大小为32KB，采用伙伴系统分配$order\geq5$时就会出现上述的问题**]。slab分配器通过着色使得slab对象能够均匀的使用高速缓存，提高高速缓存的利用率。</p>
<h3 id="基本数据结构">基本数据结构</h3>
<p><code>struct kmem_cache</code>、<code>struct array_cache</code>、<code>struct kmem_cache_node</code></p>
<p>程序经常需要创建一些数据结构，比如进程描述符task_struct，内存描述符mm_struct等。slab分配器把这些需要分配的小块内存区作为对象，类似面向对象的思想。每一类对象分配一个cache，cache有一个或多个slab组成，slab由一个或多个物理页面组成。需要分配对象的时候从slab中空闲的对象取，用完了再放回slab中，而不是释放给物理页分配器，这样下次用的时候就不用重新初始化了，实现了对象的复用。</p>
<p><img src="../../../static/img/image-20200402195625069.png" alt="image-20200402195625069"></p>
<h3 id="鸡和蛋问题">鸡和蛋问题</h3>
<p>由于slab分配器对象（<code>struct kmem_cache、struct array_cache、struct kmem_cache_node</code>）也需要用slab分配器提供的高速缓存机制，那么问题是：先有高速缓存还是先有slab分配器对象。</p>
<ol>
<li>我们知道slab分配器对象用来管理高速缓存：假设先有高速缓存的话，那么谁来管理高速缓存呢？</li>
<li>我们知道高速缓存用来存放slab分配器对象：假设先有slab分配器对象，那么它存放在哪里呢？</li>
</ol>
<p>linux的做法是：静态分配slab分配器对象内存空间，然后利用伙伴算法分配存储对象的页帧，</p>
<p>static struct kmem_cache kmem_cache_boot</p>
<p>#define NUM_INIT_LISTS (2 * MAX_NUMNODES)</p>
<p>static struct kmem_cache_node __initdata init_kmem_cache_node[NUM_INIT_LISTS];</p>
<p>struct kmem_cache *</p>
<p>kmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1]</p>
<p>每种对象类型对应一个高速缓存，kmalloc使用的是通用高速缓存</p>
<p>高速缓存划分为slab，slab有一个或多个物理上连续的页组成（一般是一个页），每个告诉缓存由多个slab</p>
<p>每个slab包含数据结构，</p>
<p>slab状态：满、部分满、空</p>
<p>部分满》空》创建一个slab</p>
<h3 id="slab着色原理">slab着色原理</h3>
<p>一般情况下，slab的大小为4KB。我们令cpu的L1 cache为32KB（每一行64B、512行），那么要填充满cpu的L1 cache需要8个slab。那么slab分配器会从伙伴分配系统中分配8个slab，也就是8个页（8个页不一定是物理连续的）。假设获取的8个页对应的的起始地址和终止地址如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="mh">0x10000000</span> <span class="o">-</span> <span class="mh">0x10001000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10010000</span> <span class="o">-</span> <span class="mh">0x10011000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10020000</span> <span class="o">-</span> <span class="mh">0x10021000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10030000</span> <span class="o">-</span> <span class="mh">0x10031000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10040000</span> <span class="o">-</span> <span class="mh">0x10041000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10050000</span> <span class="o">-</span> <span class="mh">0x10051000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10060000</span> <span class="o">-</span> <span class="mh">0x10061000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10070000</span> <span class="o">-</span> <span class="mh">0x10071000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
</code></pre></td></tr></table>
</div>
</div><p>可以发现不同的slab起始地址映射到cpu cache的同一行。slab着色原理是利用浪费的空间，假设浪费的空间所占用的cache行是$[1,10)$。那么slab中对象实际占用的cache行是$0\cup[11,64)$。那么可以通过偏移来让部分的对象移动到$[1,10)$行内。尽管slab着色可以使得对象尽可能占满cache，但是slab的着色仍然有很大的限制：</p>
<ol>
<li>无法占满剩余的行数，上述实例中$[64,512)$仍然未被使用；</li>
<li>当slab的个数超过颜色数，效果甚微；</li>
<li>slab的着色是用空间换时间，浪费一些空间来提高cache的命中率。</li>
</ol>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8slab%E5%88%86%E9%85%8D%E5%99%A8/" term="linux内核、slab分配器" label="linux内核、slab分配器" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">作用域、链接、存储类型</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/c/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/" />
            <id>https://chengshuyi.github.io/posts/c/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</id>
            <updated>2020-04-22T11:16:36+00:00</updated>
            <published>2020-04-02T13:41:27+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[在开发中经常会使用到static和extern等关键字，它们会涉及到c语言中的作用域、链接和存储期等概念。作用域和链接描述了标识符的可见性，存储期描述了通过这些标识符访……]]></summary>
            
                <content type="html"><![CDATA[<p>在开发中经常会使用到static和extern等关键字，它们会涉及到c语言中的作用域、链接和存储期等概念。作用域和链接描述了标识符的可见性，存储期描述了通过这些标识符访问的对象的生存期。</p>
<h3 id="作用域">作用域</h3>
<p>作用域描述了标识符可见范围，包括：文件作用域、代码块作用域、函数作用域、函数原型作用域。</p>
<h4 id="文件作用域">文件作用域</h4>
<p>在所有代码块之外的声明的标识符具有文件作用域；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>先声明再使用；</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 				<span class="c1">//error: &#39;a&#39; was not declared in this scope
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="代码块作用域">代码块作用域</h4>
<p>花括号之间声明的标识符具有块作用域；</p>
<blockquote>
<p>函数定义的形式参数也具有块作用域。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 				<span class="c1">//error: &#39;a&#39; was not declared in this scope
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="函数原型作用域">函数原型作用域</h4>
<p>函数原型中声明的参数名具有函数原型作用域；范围是从形参定义处到函数原型声明的结束。</p>
<blockquote>
<p>唯一要注意的是在函数原型中的参数名字不能重复；</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//redefinition of &#39;int a&#39;
</span></code></pre></td></tr></table>
</div>
</div><h4 id="函数作用域">函数作用域</h4>
<p>一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数；</p>
<blockquote>
<p>只适用于语句标签</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
<span class="nl">ret</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>			<span class="c1">//error: label &#39;ret&#39; used but not defined
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="nl">ret</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="nl">ret</span><span class="p">:</span> 			<span class="c1">//error: duplicate label &#39;ret&#39;
</span><span class="c1"></span>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="链接属性">链接属性</h3>
<p>C 变量有 3 种链接属性：外部链接、内部链接或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是外部链接或内部链接。<strong>外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用</strong>。</p>
<p>static关键字可以使一个<strong>外部链接</strong>变成内部链接（<strong>注意：1. 无法将无链接的变成内部链接，比如在函数内声明static变量，其链接属性仍然是无连接。2. static无法改变标识符的作用域</strong>），即每一个翻译单元都单独享有static声明的标识符。本例有两个源文件：<code>file1.c</code>和<code>file2.c</code>，源文件都包含同一个头文件<code>file.h</code>。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//file.h 
</span><span class="c1"></span><span class="cp">#ifndef TEST_FILE_H
</span><span class="cp">#define TEST_FILE_H
</span><span class="cp"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">file1_modify_static</span><span class="p">();</span>
<span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//file1.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;file.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">file1_modify_static</span><span class="p">(){</span>
	<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__func__</span><span class="o">&lt;&lt;</span><span class="s">&#34;: a is &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//file2.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;file.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__func__</span><span class="o">&lt;&lt;</span><span class="s">&#34;: a is &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">file1_modify_static</span><span class="p">();</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__func__</span><span class="o">&lt;&lt;</span><span class="s">&#34;: a is &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最终的输出是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">main</span><span class="p">:</span> <span class="n">a</span> <span class="n">is</span> <span class="mi">0</span>
<span class="nl">file1_modify_static</span><span class="p">:</span> <span class="n">a</span> <span class="n">is</span> <span class="mi">1</span>
<span class="nl">main</span><span class="p">:</span> <span class="n">a</span> <span class="n">is</span> <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到文件1和文件2修改的a不是同一个a，说明static将变量a变成了内部链接。</p>
<h3 id="存储期">存储期</h3>
<p>C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。这里主要需要了解静态存储期和自动存储期：</p>
<ol>
<li>
<p>如果对象具有静态存储期，那么它在程序的执行期间一直存在。</p>
</li>
<li>
<p>块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。</p>
</li>
</ol>
<h3 id="总结">总结</h3>
<p><img src="C:%5CUsers%5Cc1527%5CDesktop%5Chugo_0.68.3_Windows-64bit%5Cblog%5Cstatic%5Cimg%5Cimage-20200402133937695.png" alt="image-20200402133937695"></p>
<blockquote>
<p>static关键字的作用</p>
</blockquote>
<ol>
<li>
<p>static用于修改标识符的链接属性，将其链接属性从<strong>外部链接</strong>转换成内部链接，使得改标识符只能由该源文件访问，但标识符的存储期和作用域不受影响；</p>
<blockquote>
<p>外部链接和内部链接的存储期和作用域都一样，属于：文件作用域，静态存储期</p>
</blockquote>
</li>
<li>
<p>static用于块作用域的标识符声明时，将其从自动变量转换成静态变量，但变量的链接属性和作用域不受影响。</p>
</li>
</ol>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/c%E8%AF%AD%E8%A8%80/" term="c语言" label="c语言" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/c%E8%AF%AD%E8%A8%80c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" term="c语言、c语言基础概念" label="c语言、c语言基础概念" />
                            
                        
                    
                
            
        </entry>
    
</feed>
