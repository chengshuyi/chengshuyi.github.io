<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">程书意</title>
    <subtitle type="html">MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</subtitle>
    <updated>2020-06-17T13:19:15+00:00</updated>
    <id>https://chengshuyi.github.io/</id>
    <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/" />
    <link rel="self" type="application/atom+xml" href="https://chengshuyi.github.io/atom.xml" />
    <author>
            <name>程书意</name>
            <uri>https://chengshuyi.github.io/</uri>
            
                <email>c15271843451@outlook.com</email>
            </author>
    <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    <generator uri="https://gohugo.io/" version="0.68.3">Hugo</generator>
        <entry>
            <title type="text">Fat32文件系统详解</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/filesystem/fat/" />
            <id>https://chengshuyi.github.io/posts/filesystem/fat/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-05-14T20:06:37+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[本文主要介绍了fat32文件系统，包括硬盘分区的格式、文件分配表和目录项等重要内容。 下面简要的描述fat32文件系统比较关键的两个函数： f_mount函数：在指定的硬盘……]]></summary>
            
                <content type="html"><![CDATA[<p>本文主要介绍了fat32文件系统，包括硬盘分区的格式、文件分配表和目录项等重要内容。</p>
<p>下面简要的描述fat32文件系统比较关键的两个函数：</p>
<ol>
<li>
<p><code>f_mount</code>函数：在指定的硬盘上挂载文件系统（主要是读取引导区和<code>Volume ID</code>）；</p>
</li>
<li>
<p><code>f_open</code>函数：</p>
<p>a. 首先去根目录区（0x02H簇号），找到该文件的根目录（主要是匹配目录项，一个目录项占32B，所以一个簇大概$2^n<em>512/32=2^n</em>16$个目录项）；</p>
<p>b. 查看当前目录项属性，如果是子目录，则查找下一个目录项（类似于步骤a）。如果是当前要查找的文件，则查找完毕；</p>
</li>
</ol>
<h3 id="fat32磁盘空间的划分">fat32磁盘空间的划分</h3>
<p>首先第一个扇区（512字节）作为引导扇区，其中引导扇区记录了当前硬盘的分区情况，以及每个分区所包含的信息：文件系统类型、分区开始的扇区和占用扇区的个数；</p>
<p>然后根据对应的分区可以找到该分区的第一个扇区，该扇区称为<code>volume ID</code>。<code>volume ID</code>包含了一些关于当前文件系统的重要信息，以fat32为例：</p>
<ul>
<li>每个扇区占多少字节（总是512字节）；</li>
<li>每个簇有多少个扇区（2的n次方）</li>
<li>保留扇区的个数；</li>
<li>文件分配表的个数（总是2，有一个是备份）；</li>
<li>文件分配表占用的扇区数（根据分区大小计算即可）；</li>
<li>根目录所在的簇（一般是2）；</li>
</ul>
<p>接着是保留扇区空间；</p>
<p>再接着是文件分配表区（显示链接法）：</p>
<ul>
<li>fat32说明其文件分配表的表项是32位的；</li>
<li>每一个表项的位置代表着一个簇号，该表项的值表示下一个簇号；</li>
</ul>
<p>最后是数据区，不仅包含了文件数据还包含了文件系统数据。</p>
<h3 id="引导区">引导区</h3>
<p>硬盘的第一个扇区称为引导区，也叫主引导扇区（MBR）。Boot Code也就是我们常说的bootloader代码。partition n表示分区，可以看到最多支持四个分区。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200514222207.png" alt=""></p>
<p>这里我们主要看下分区描述符所占的16字节包含哪些信息？格式如下图所示：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200602135143.png" alt=""></p>
<p>重要的信息有三个：</p>
<ol>
<li>Type code：表明当前文件系统的类型；</li>
<li>LBA Begin：当前分区起始扇区号；</li>
<li>Number of Sectors：当前分区占有多少扇区；</li>
</ol>
<h3 id="volume-id">volume ID</h3>
<p>分区的第一个扇区称为<code>volume ID</code>。<code>volume ID</code>包含了一些关于当前文件系统的重要信息：</p>
<ul>
<li>每个扇区占多少字节（总是512字节）；</li>
<li>每个簇有多少个扇区（2的n次方）</li>
<li>保留扇区的个数；</li>
<li>文件分配表的个数（总是2，有一个是备份）；</li>
<li>文件分配表占用的扇区数（根据分区大小计算即可）；</li>
<li>根目录所在的簇（一般是2）；</li>
</ul>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200602135838.png" alt=""></p>
<h3 id="保留扇区">保留扇区</h3>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200602161814.png" alt=""></p>
<h3 id="文件分配表区">文件分配表区</h3>
<p>文件分配表区是FAT文件系统管理磁盘空间和文件的最重要区域，它保存逻辑盘数据区各簇使用情况信息，采用<strong>位示图法</strong>来表示，文件所占用的存储空间及空闲空间的管理都是通过FAT实现的。FAT区共保存了两个相同的文件分配表, 便于第一个损坏时, 还有第二个可用。</p>
<p>一个扇区的大小是512B，那么一个扇区可以存放128个簇号。因此，32bit的值中高7-31位表示扇区号（当前FAT表该簇号所在的扇区），低7位表示偏移（便宜单位是32bit）。</p>
<p><strong>未被分配使用和已回收</strong>的簇相应位置写零，<strong>坏簇</strong>相应位置填入特定值 0FFFFFF7H 标识，<strong>已分配</strong>的簇相应位置填入非零值，具体为：如果该簇是文件的<strong>最后一簇</strong>, 填入的值为 0FFFFFFFH, 如果该簇<strong>不是文件的最后一簇</strong>，填入的值为该文件占用的下一个簇的簇号，这样，正好将文件占用的各簇构成一个簇链，保存在FAT32 表中。</p>
<h3 id="数据区">数据区</h3>
<p>数据区是存放文件数据的地方，这里需要特别考虑根目录区或者目录区。FAT32 文件系统中，根目录作为数据区的一部分，采用与子目录相似的管理方式，这 一点 与FAT12、FAT16明显不同，如FAT16文件系统的根目录区( ROOT区) 是固定区域、固定大小的，占用从FAT区之后紧接着的32个扇区，最多保存 512 个目录项( 其根目录保存的文件数受限的原因在此) ，作为系统区的一部分。FAT32的根目录一般情况下从02H簇开始使用，大小视需要增加，因此根目录下的文件数目不再受最多 512 的限制。</p>
<p>下图是目录项的格式：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200602162221.png" alt=""></p>
<p>其中比较重要的有：</p>
<ul>
<li>短文件名：8+3格式；</li>
<li>文件属性：只读、隐藏、是否为子目录等；</li>
<li>簇号（HIgh）：存储文件起始簇的簇号的高16位；</li>
<li>簇号（Low）：存储文件起始簇的簇号的低16位；</li>
<li>大小：文件的长度；</li>
</ul>
<!-- ### 专业名词缩写

LBA:logical block addressing

MBR:master Boot Record

CHS:Cylinder Head Sector -->
<h3 id="参考文献">参考文献</h3>
<p>[1]. Understanding FAT32 Filesystems. <a href="https://www.pjrc.com/tech/8051/ide/fat32.html">https://www.pjrc.com/tech/8051/ide/fat32.html</a>.</p>
<p>[2]. 张明亮, 张宗杰. 浅析FAT32文件系统[J]. 计算机与数字工程, 2005(01):56-59.</p>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" term="文件系统" label="文件系统" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" term="文件系统" label="文件系统" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">bpf的jit编译器</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/bpf%E7%9A%84jit%E7%BC%96%E8%AF%91%E5%99%A8/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/bpf%E7%9A%84jit%E7%BC%96%E8%AF%91%E5%99%A8/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-05-10T16:33:22+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[2001年，Eric Dumazet往bpf添加了jit（just in time）compiler功能，加速了bpf filter程序运行时间（包含编译+运行）。在上一篇博文，……]]></summary>
            
                <content type="html"><![CDATA[<p>2001年，Eric Dumazet往bpf添加了jit（just in time）compiler功能，加速了bpf filter程序运行时间（包含编译+运行）。在<a href="https://chengshuyi.github.io/posts/linux-kernel/bpf-paper/">上一篇博文</a>，我们知道bpf的原始filter程序是通过翻译一条指令也代表着执行一条指令（没有转换成对应机器的机器码的过程），没有编译的过程。jit编译器可以将bpf的filter程序（伪代码）编译成可以直接在主机运行的机器码。该<a href="https://lwn.net/Articles/437884/">patch</a>实现了bfp程序到x86_64机器码的转换。</p>
<p>本文简单介绍了jit编译器的原理，并有实例分析。</p>
<h3 id="jit编译器">jit编译器</h3>
<p>jit编译器的出现更多的是为了不同指令集之间的转换，对应着也就是跨平台的实现。以java和c为例，java的运行程序（字节码）可以在任意平台上运行，而c语言运行程序不行。这是因为java在不同的平台都配置有相应的jit编译器。在程序运行的时候，jit编译器会将字节码转换成对应平台的指令，然后执行。</p>
<ol>
<li>
<p>为什么不将程序编译好后运行，而是要运行时编译，再执行？</p>
<p>静态编译能够对程序做以比jit编译器更大的优化，但是静态编译生成的可执行文件并不能跨平台。jit编译器虽然优化能力有限，但是能够对一条指令在不同的平台实现对应的转换，达到跨平台的目的。</p>
</li>
</ol>
<h3 id="bpf-jit编译器">bpf jit编译器</h3>
<p>本节介绍了bpf的jit编译器的具体实现，为了更好的了解jit编译器实现的原理。我们先看一个具体示例，即bpf filter程序和编译后的程序对比；最后我们给出jit编译器的源码，分析整个的工作流程。</p>
<p>bpf filter程序使用的寄存器都是伪寄存器，jit首先要将其与物理寄存器对应起来：</p>
<ul>
<li>
<p>BPF的accumulator寄存器对应着x86_64平台下的eax寄存器；</p>
</li>
<li>
<p>BPF的index寄存器对应着x86_64平台下的ebx寄存器；</p>
</li>
<li>
<p>使用rdi寄存器存放skb的首地址；</p>
</li>
<li>
<p>使用rbp存放frame的首地址；</p>
</li>
<li>
<p>r9存放头部长度；</p>
</li>
<li>
<p>r8存放数据的首地址；</p>
</li>
</ul>
<pre><code># jit filter程序
(000) ldh      [12]
(001) jeq      #0x800           jt 2	jf 6
(002) ld       [26]
(003) jeq      #0xc0a80001      jt 12	jf 4
(004) ld       [30]
(005) jeq      #0xc0a80001      jt 12	jf 13
(006) jeq      #0x806           jt 8	jf 7
(007) jeq      #0x8035          jt 8	jf 13
(008) ld       [28]
(009) jeq      #0xc0a80001      jt 12	jf 10
(010) ld       [38]
(011) jeq      #0xc0a80001      jt 12	jf 13
(012) ret      #65535
(013) ret      #0
# jit编译后的机器码
JIT code: ffffffffa00d5000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 60
JIT code: ffffffffa00d5010: 44 2b 4f 64 4c 8b 87 b8 00 00 00 be 0c 00 00 00
JIT code: ffffffffa00d5020: e8 24 1b 2f e1 3d 00 08 00 00 75 24 be 1a 00 00
JIT code: ffffffffa00d5030: 00 e8 fe 1a 2f e1 3d 01 00 a8 c0 74 43 be 1e 00
JIT code: ffffffffa00d5040: 00 00 e8 ed 1a 2f e1 3d 01 00 a8 c0 74 32 eb 37
JIT code: ffffffffa00d5050: 3d 06 08 00 00 74 07 3d 35 80 00 00 75 29 be 1c
JIT code: ffffffffa00d5060: 00 00 00 e8 cc 1a 2f e1 3d 01 00 a8 c0 74 11 be
JIT code: ffffffffa00d5070: 26 00 00 00 e8 bb 1a 2f e1 3d 01 00 a8 c0 75 07
JIT code: ffffffffa00d5080: b8 ff ff 00 00 eb 02 31 c0 c9 c3
# 机器码转换成便于分析的汇编代码
0000: push %rbp
	  mov %rsp,%rbp
0004: subq $96,%rsp
0008: mov %rbx, -8(%rbp)
000c: mov off8(%rdi),%r9d
0010: sub off8(%rdi),%r9d
0014: mov off32(%rdi),%r8   b8 00 00 00
001c: mov 0x0c,%esi
0020: call function(addr is 0xe12f1b24)
0025: cmp #0x800,%eax
002a: jne 0x24
002c: mov $26,%esi
0031: call function(addr is 0xe12f1afe)
0036: cmp $0xc0a80001,%eax
003b: je 0x43
003d: mov $30,%esi
0042: call function(addr is 0xe12f1aed)
0047: cmp $0xc0a80001,%eax
004c: je 0x32
004e: jmp 0x37
0050: cmp $0x806,%eax
0055: je 0x07
0057: cmp $0x8035,%eax
005d: jne 0x29
005e: jmp 0x1c
0063: call function(addr is 0xe12f1acc)
0068: cmp $0xc0a80001,%eax
006d: je 0x11
006f: mov 0x26,%esi 
0074: call function(addr is 0xe12f1abb)
0079: cmp $0xc0a80001,%eax
007e: jne 0x07
mov $65535,%eax 
jmp 02
xor %eax,%eax
leaveq
ret
</code></pre><p>下面是jit编译的源码，有删除一部分。同时，给了一部分的注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span><span class="lnt">427
</span><span class="lnt">428
</span><span class="lnt">429
</span><span class="lnt">430
</span><span class="lnt">431
</span><span class="lnt">432
</span><span class="lnt">433
</span><span class="lnt">434
</span><span class="lnt">435
</span><span class="lnt">436
</span><span class="lnt">437
</span><span class="lnt">438
</span><span class="lnt">439
</span><span class="lnt">440
</span><span class="lnt">441
</span><span class="lnt">442
</span><span class="lnt">443
</span><span class="lnt">444
</span><span class="lnt">445
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/moduleloader.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;asm/cacheflush.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/netdevice.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/filter.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cm">/*
</span><span class="cm"> * Conventions :
</span><span class="cm"> *  EAX : BPF A accumulator
</span><span class="cm"> *  EBX : BPF X accumulator
</span><span class="cm"> *  RDI : pointer to skb   (first argument given to JIT function)
</span><span class="cm"> *  RBP : frame pointer (even if CONFIG_FRAME_POINTER=n)
</span><span class="cm"> *  r9d : skb-&gt;len - skb-&gt;data_len (headlen)
</span><span class="cm"> *  r8  : skb-&gt;data
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="n">bpf_jit_enable</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*
</span><span class="cm"> * assembly code in net/core/bpf_jit.S
</span><span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">sk_load_word</span><span class="p">[],</span> <span class="n">sk_load_half</span><span class="p">[],</span> <span class="n">sk_load_byte</span><span class="p">[],</span> <span class="n">sk_load_byte_msh</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">u8</span> <span class="n">sk_load_word_ind</span><span class="p">[],</span> <span class="n">sk_load_half_ind</span><span class="p">[],</span> <span class="n">sk_load_byte_ind</span><span class="p">[];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">emit_code</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define EMIT(bytes, len)	do { prog = emit_code(prog, bytes, len); } while (0)
</span><span class="cp"></span>
<span class="cp">#define EMIT1(b1)		EMIT(b1, 1)
</span><span class="cp">#define EMIT2(b1, b2)		EMIT((b1) + ((b2) &lt;&lt; 8), 2)
</span><span class="cp">#define EMIT3(b1, b2, b3)	EMIT((b1) + ((b2) &lt;&lt; 8) + ((b3) &lt;&lt; 16), 3)
</span><span class="cp">#define EMIT4(b1, b2, b3, b4)   EMIT((b1) + ((b2) &lt;&lt; 8) + ((b3) &lt;&lt; 16) + ((b4) &lt;&lt; 24), 4)
</span><span class="cp">#define EMIT1_off32(b1, off)	do { EMIT1(b1); EMIT(off, 4);} while (0)
</span><span class="cp"></span>
<span class="cp">#define CLEAR_A() EMIT2(0x31, 0xc0) </span><span class="cm">/* xor %eax,%eax */</span><span class="cp">
</span><span class="cp">#define CLEAR_X() EMIT2(0x31, 0xdb) </span><span class="cm">/* xor %ebx,%ebx */</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_imm8</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">127</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">128</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_near</span><span class="p">(</span><span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="mi">127</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">128</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define EMIT_JMP(offset)						\
</span><span class="cp">do {									\
</span><span class="cp">	if (offset) {							\
</span><span class="cp">		if (is_near(offset))					\
</span><span class="cp">			EMIT2(0xeb, offset); </span><span class="cm">/* jmp .+off8 */</span><span class="cp">		\
</span><span class="cp">		else							\
</span><span class="cp">			EMIT1_off32(0xe9, offset); </span><span class="cm">/* jmp .+off32 */</span><span class="cp">	\
</span><span class="cp">	}								\
</span><span class="cp">} while (0)
</span><span class="cp"></span>
<span class="cm">/* list of x86 cond jumps (. + s8)
</span><span class="cm"> * Add 0x10 (and an extra 0x0f) to generate far jumps (. + s32)
</span><span class="cm"> */</span>
<span class="cp">#define X86_JB  0x72
</span><span class="cp">#define X86_JAE 0x73
</span><span class="cp">#define X86_JE  0x74
</span><span class="cp">#define X86_JNE 0x75
</span><span class="cp">#define X86_JBE 0x76
</span><span class="cp">#define X86_JA  0x77
</span><span class="cp"></span>
<span class="cp">#define EMIT_COND_JMP(op, offset)				\
</span><span class="cp">do {								\
</span><span class="cp">	if (is_near(offset))					\
</span><span class="cp">		EMIT2(op, offset); </span><span class="cm">/* jxx .+off8 */</span><span class="cp">		\
</span><span class="cp">	else {							\
</span><span class="cp">		EMIT2(0x0f, op + 0x10);				\
</span><span class="cp">		EMIT(offset, 4); </span><span class="cm">/* jxx .+off32 */</span><span class="cp">		\
</span><span class="cp">	}							\
</span><span class="cp">} while (0)
</span><span class="cp"></span>
<span class="cp">#define COND_SEL(CODE, TOP, FOP)	\
</span><span class="cp">	case CODE:			\
</span><span class="cp">		t_op = TOP;		\
</span><span class="cp">		f_op = FOP;		\
</span><span class="cp">		goto cond_branch
</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">bpf_jit_compile</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">temp</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="c1">// 编译后生成的机器码
</span><span class="c1"></span>	<span class="n">u8</span> <span class="o">*</span><span class="n">prog</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">proglen</span><span class="p">,</span> <span class="n">oldproglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ilen</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t_offset</span><span class="p">,</span> <span class="n">f_offset</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">t_op</span><span class="p">,</span> <span class="n">f_op</span><span class="p">,</span> <span class="n">seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pass</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pc_ret0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* bpf index of first RET #0 instruction (if any) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cleanup_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sock_filter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">insns</span><span class="p">;</span>
	<span class="c1">// filter程序的指令个数
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">flen</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpf_jit_enable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">addrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">flen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addrs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Before first pass, make a rough estimation of addrs[]
</span><span class="cm">	 * each bpf instruction is translated to less than 64 bytes
</span><span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">proglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proglen</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cleanup_addr</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span> <span class="cm">/* epilogue address */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no prologue/epilogue for trivial filters (RET something) */</span>
		<span class="n">proglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">prog</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

		<span class="c1">// 第一遍不做翻译，只是浏览整个程序是否包含某些指令，主要是为了处理prologue和epilogue
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">seen</span><span class="p">)</span> <span class="p">{</span>
		    <span class="c1">// prologue
</span><span class="c1"></span>			<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xe5</span><span class="p">);</span> <span class="cm">/* push %rbp; mov %rsp,%rbp */</span>
			<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xec</span><span class="p">,</span> <span class="mi">96</span><span class="p">);</span>	<span class="cm">/* subq  $96,%rsp	*/</span>
			<span class="cm">/* note : must save %rbx in case bpf_error is hit */</span>
			<span class="c1">// 保存callee register
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SEEN_XREG</span> <span class="o">|</span> <span class="n">SEEN_DATAREF</span><span class="p">))</span>
				<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">);</span> <span class="cm">/* mov %rbx, -8(%rbp) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_XREG</span><span class="p">)</span>
				<span class="n">CLEAR_X</span><span class="p">();</span> <span class="cm">/* make sure we dont leek kernel memory */</span>
			<span class="c1">// 传递参数
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_DATAREF</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">127</span><span class="p">)</span>
					<span class="cm">/* mov    off8(%rdi),%r9d */</span>
					<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x4f</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* mov    off32(%rdi),%r9d */</span>
					<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x8f</span><span class="p">);</span>
					<span class="n">EMIT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_imm8</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data_len</span><span class="p">)))</span>
					<span class="cm">/* sub    off8(%rdi),%r9d */</span>
					<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span> <span class="mh">0x4f</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data_len</span><span class="p">));</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span> <span class="mh">0x8f</span><span class="p">);</span>
					<span class="n">EMIT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data_len</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">is_imm8</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span>
					<span class="cm">/* mov off8(%rdi),%r8 */</span>
					<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x4c</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data</span><span class="p">));</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* mov off32(%rdi),%r8 */</span>
					<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x4c</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">);</span>
					<span class="n">EMIT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">data</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
        <span class="c1">// 解析bpf的第一条指令
</span><span class="c1"></span>		<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nl">BPF_S_RET_K</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_LD_W_LEN</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_ANC_PROTOCOL</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_ANC_IFINDEX</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_ANC_MARK</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_ANC_RXHASH</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_ANC_CPU</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_LD_W_ABS</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_LD_H_ABS</span><span class="p">:</span>
		<span class="k">case</span> <span class="nl">BPF_S_LD_B_ABS</span><span class="p">:</span>
			<span class="cm">/* first instruction sets A register (or is RET &#39;constant&#39;) */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="n">CLEAR_A</span><span class="p">();</span> <span class="cm">/* A = 0 */</span>
		<span class="p">}</span>
        <span class="c1">// 编译每一条bpf filter程序指令
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">flen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">k</span><span class="p">;</span>
            <span class="c1">// 解析bpf指令的操作码
</span><span class="c1"></span>			<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nl">BPF_S_ALU_ADD_X</span><span class="p">:</span> <span class="cm">/* A += X; */</span>
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xd8</span><span class="p">);</span>		<span class="cm">/* add %ebx,%eax */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_ALU_ADD_K</span><span class="p">:</span> <span class="cm">/* A += K; */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">K</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_imm8</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
					<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>	<span class="cm">/* add imm8,%eax */</span>
				<span class="k">else</span>
					<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0x05</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>	<span class="cm">/* add imm32,%eax */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_ALU_MUL_X</span><span class="p">:</span> <span class="cm">/* A *= X; */</span>
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0xaf</span><span class="p">,</span> <span class="mh">0xc3</span><span class="p">);</span>	<span class="cm">/* imul %ebx,%eax */</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="nl">BPF_S_RET_K</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">K</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pc_ret0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
						<span class="n">pc_ret0</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">CLEAR_A</span><span class="p">();</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xb8</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>	<span class="cm">/* mov $imm32,%eax */</span>
				<span class="p">}</span>
				<span class="cm">/* fallinto */</span>
			<span class="k">case</span> <span class="nl">BPF_S_RET_A</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">seen</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">flen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">EMIT_JMP</span><span class="p">(</span><span class="n">cleanup_addr</span> <span class="o">-</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_XREG</span><span class="p">)</span>
						<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">);</span>  <span class="cm">/* mov  -8(%rbp),%rbx */</span>
					<span class="n">EMIT1</span><span class="p">(</span><span class="mh">0xc9</span><span class="p">);</span>		<span class="cm">/* leaveq */</span>
				<span class="p">}</span>
				<span class="n">EMIT1</span><span class="p">(</span><span class="mh">0xc3</span><span class="p">);</span>		<span class="cm">/* ret */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_MEM</span><span class="p">:</span> <span class="cm">/* A = mem[K] : mov off8(%rbp),%eax */</span>
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_MEM</span><span class="p">;</span>
				<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0xf0</span> <span class="o">-</span> <span class="n">K</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LDX_MEM</span><span class="p">:</span> <span class="cm">/* X = mem[K] : mov off8(%rbp),%ebx */</span>
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span> <span class="o">|</span> <span class="n">SEEN_MEM</span><span class="p">;</span>
				<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0xf0</span> <span class="o">-</span> <span class="n">K</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_W_LEN</span><span class="p">:</span> <span class="cm">/*	A = skb-&gt;len; */</span>
				<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">FIELD_SIZEOF</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_imm8</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
					<span class="cm">/* mov    off8(%rdi),%eax */</span>
					<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">);</span>
					<span class="n">EMIT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LDX_W_LEN</span><span class="p">:</span> <span class="cm">/* X = skb-&gt;len; */</span>
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_imm8</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">)))</span>
					<span class="cm">/* mov off8(%rdi),%ebx */</span>
					<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x5f</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x9f</span><span class="p">);</span>
					<span class="n">EMIT</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_ANC_CPU</span><span class="p">:</span>
<span class="cp">#ifdef CONFIG_SMP
</span><span class="cp"></span>				<span class="n">EMIT4</span><span class="p">(</span><span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">);</span> <span class="cm">/* mov %gs:off32,%eax */</span>
				<span class="n">EMIT</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cpu_number</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="cm">/* A = smp_processor_id(); */</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="n">CLEAR_A</span><span class="p">();</span>
<span class="cp">#endif
</span><span class="cp"></span>				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_W_ABS</span><span class="p">:</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_word</span><span class="p">;</span>
<span class="nl">common_load</span><span class="p">:</span>			<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_DATAREF</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="n">t_offset</span> <span class="o">=</span> <span class="n">func</span> <span class="o">-</span> <span class="p">(</span><span class="n">image</span> <span class="o">+</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xbe</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span> <span class="cm">/* mov imm32,%esi */</span>
				<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xe8</span><span class="p">,</span> <span class="n">t_offset</span><span class="p">);</span> <span class="cm">/* call */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_H_ABS</span><span class="p">:</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_half</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_B_ABS</span><span class="p">:</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_byte</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">common_load</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LDX_B_MSH</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pc_ret0</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">EMIT_JMP</span><span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="n">pc_ret0</span><span class="p">]</span> <span class="o">-</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">CLEAR_A</span><span class="p">();</span>
					<span class="n">EMIT_JMP</span><span class="p">(</span><span class="n">cleanup_addr</span> <span class="o">-</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_DATAREF</span> <span class="o">|</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">t_offset</span> <span class="o">=</span> <span class="n">sk_load_byte_msh</span> <span class="o">-</span> <span class="p">(</span><span class="n">image</span> <span class="o">+</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xbe</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>	<span class="cm">/* mov imm32,%esi */</span>
				<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xe8</span><span class="p">,</span> <span class="n">t_offset</span><span class="p">);</span> <span class="cm">/* call sk_load_byte_msh */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_W_IND</span><span class="p">:</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_word_ind</span><span class="p">;</span>
<span class="nl">common_load_ind</span><span class="p">:</span>		<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_DATAREF</span> <span class="o">|</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
				<span class="n">t_offset</span> <span class="o">=</span> <span class="n">func</span> <span class="o">-</span> <span class="p">(</span><span class="n">image</span> <span class="o">+</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xbe</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span>	<span class="cm">/* mov imm32,%esi   */</span>
				<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xe8</span><span class="p">,</span> <span class="n">t_offset</span><span class="p">);</span>	<span class="cm">/* call sk_load_xxx_ind */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_H_IND</span><span class="p">:</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_half_ind</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">common_load_ind</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_LD_B_IND</span><span class="p">:</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">sk_load_byte_ind</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">common_load_ind</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">BPF_S_JMP_JA</span><span class="p">:</span>
				<span class="n">t_offset</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">K</span><span class="p">]</span> <span class="o">-</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">EMIT_JMP</span><span class="p">(</span><span class="n">t_offset</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGT_K</span><span class="p">,</span> <span class="n">X86_JA</span><span class="p">,</span> <span class="n">X86_JBE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGE_K</span><span class="p">,</span> <span class="n">X86_JAE</span><span class="p">,</span> <span class="n">X86_JB</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JEQ_K</span><span class="p">,</span> <span class="n">X86_JE</span><span class="p">,</span> <span class="n">X86_JNE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JSET_K</span><span class="p">,</span><span class="n">X86_JNE</span><span class="p">,</span> <span class="n">X86_JE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGT_X</span><span class="p">,</span> <span class="n">X86_JA</span><span class="p">,</span> <span class="n">X86_JBE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JGE_X</span><span class="p">,</span> <span class="n">X86_JAE</span><span class="p">,</span> <span class="n">X86_JB</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JEQ_X</span><span class="p">,</span> <span class="n">X86_JE</span><span class="p">,</span> <span class="n">X86_JNE</span><span class="p">);</span>
			<span class="n">COND_SEL</span><span class="p">(</span><span class="n">BPF_S_JMP_JSET_X</span><span class="p">,</span><span class="n">X86_JNE</span><span class="p">,</span> <span class="n">X86_JE</span><span class="p">);</span>

<span class="nl">cond_branch</span><span class="p">:</span>
			    <span class="n">f_offset</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">]</span> <span class="o">-</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">t_offset</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span><span class="p">]</span> <span class="o">-</span> <span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

				<span class="cm">/* same targets, can avoid doing the test :) */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span> <span class="o">==</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">EMIT_JMP</span><span class="p">(</span><span class="n">t_offset</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JGT_X</span><span class="p">:</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JGE_X</span><span class="p">:</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JEQ_X</span><span class="p">:</span>
					<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
					<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0x39</span><span class="p">,</span> <span class="mh">0xd8</span><span class="p">);</span> <span class="cm">/* cmp %ebx,%eax */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JSET_X</span><span class="p">:</span>
					<span class="n">seen</span> <span class="o">|=</span> <span class="n">SEEN_XREG</span><span class="p">;</span>
					<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0x85</span><span class="p">,</span> <span class="mh">0xd8</span><span class="p">);</span> <span class="cm">/* test %ebx,%eax */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JEQ_K</span><span class="p">:</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0x85</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">);</span> <span class="cm">/* test   %eax,%eax */</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JGT_K</span><span class="p">:</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JGE_K</span><span class="p">:</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">127</span><span class="p">)</span>
						<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span> <span class="cm">/* cmp imm8,%eax */</span>
					<span class="k">else</span>
						<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0x3d</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span> <span class="cm">/* cmp imm32,%eax */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="nl">BPF_S_JMP_JSET_K</span><span class="p">:</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&lt;=</span> <span class="mh">0xFF</span><span class="p">)</span>
						<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0xa8</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span> <span class="cm">/* test imm8,%al */</span>
					<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">K</span> <span class="o">&amp;</span> <span class="mh">0xFFFF00FF</span><span class="p">))</span>
						<span class="n">EMIT3</span><span class="p">(</span><span class="mh">0xf6</span><span class="p">,</span> <span class="mh">0xc4</span><span class="p">,</span> <span class="n">K</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="cm">/* test imm8,%ah */</span>
					<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="o">&lt;=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">EMIT2</span><span class="p">(</span><span class="mh">0x66</span><span class="p">,</span> <span class="mh">0xa9</span><span class="p">);</span> <span class="cm">/* test imm16,%ax */</span>
						<span class="n">EMIT</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">EMIT1_off32</span><span class="p">(</span><span class="mh">0xa9</span><span class="p">,</span> <span class="n">K</span><span class="p">);</span> <span class="cm">/* test imm32,%eax */</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">)</span>
						<span class="n">t_offset</span> <span class="o">+=</span> <span class="n">is_near</span><span class="p">(</span><span class="n">f_offset</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">6</span><span class="p">;</span>
					<span class="n">EMIT_COND_JMP</span><span class="p">(</span><span class="n">t_op</span><span class="p">,</span> <span class="n">t_offset</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">jf</span><span class="p">)</span>
						<span class="n">EMIT_JMP</span><span class="p">(</span><span class="n">f_offset</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">EMIT_COND_JMP</span><span class="p">(</span><span class="n">f_op</span><span class="p">,</span> <span class="n">f_offset</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">default</span><span class="o">:</span>
				<span class="cm">/* hmm, too complex filter, give up with jit compiler */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="c1">// bpf一条指令编译后的指令长度
</span><span class="c1"></span>			<span class="n">ilen</span> <span class="o">=</span> <span class="n">prog</span> <span class="o">-</span> <span class="n">temp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">proglen</span> <span class="o">+</span> <span class="n">ilen</span> <span class="o">&gt;</span> <span class="n">oldproglen</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;bpb_jit_compile fatal error</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
					<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">);</span>
					<span class="n">module_free</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">image</span> <span class="o">+</span> <span class="n">proglen</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ilen</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">proglen</span> <span class="o">+=</span> <span class="n">ilen</span><span class="p">;</span>
			<span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span>
			<span class="n">prog</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* last bpf instruction is always a RET :
</span><span class="cm">		 * use it to give the cleanup instruction(s) addr
</span><span class="cm">		 */</span>
		<span class="c1">// 处理epilogue
</span><span class="c1"></span>		<span class="n">cleanup_addr</span> <span class="o">=</span> <span class="n">proglen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* ret */</span>
		<span class="c1">// 恢复上一个函数的rbp和rsp
</span><span class="c1"></span>		<span class="c1">// movq %rbp, %rsp
</span><span class="c1"></span>        <span class="c1">// popq %rbp
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">seen</span><span class="p">)</span>
			<span class="n">cleanup_addr</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* leaveq */</span>
        <span class="c1">// 恢复rbx寄存器的值
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">seen</span> <span class="o">&amp;</span> <span class="n">SEEN_XREG</span><span class="p">)</span>
			<span class="n">cleanup_addr</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* mov  -8(%rbp),%rbx */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
		    <span class="c1">// 编译完成，退出
</span><span class="c1"></span>		    <span class="c1">// pass = 2
</span><span class="c1"></span>			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">proglen</span> <span class="o">!=</span> <span class="n">oldproglen</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// pass = 1
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">proglen</span> <span class="o">==</span> <span class="n">oldproglen</span><span class="p">)</span> <span class="p">{</span>
		    <span class="c1">// 为代码分配内存（主要是设置page的属性为可执行，也就是指令而非数据）
</span><span class="c1"></span>		    <span class="c1">// 这也是动态模块加载可以运行的基本条件
</span><span class="c1"></span>			<span class="n">image</span> <span class="o">=</span> <span class="n">module_alloc</span><span class="p">(</span><span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span><span class="n">proglen</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span><span class="p">)));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">image</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// pass = 0
</span><span class="c1"></span>		<span class="n">oldproglen</span> <span class="o">=</span> <span class="n">proglen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;flen=%d proglen=%u pass=%d image=%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
		       <span class="n">flen</span><span class="p">,</span> <span class="n">proglen</span><span class="p">,</span> <span class="n">pass</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bpf_jit_enable</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&#34;JIT code: &#34;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span>
				       <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">proglen</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="c1">// 刷新代码到内存
</span><span class="c1"></span>		<span class="n">bpf_flush_icache</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span> <span class="o">+</span> <span class="n">proglen</span><span class="p">);</span>

		<span class="n">fp</span><span class="o">-&gt;</span><span class="n">bpf_func</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">image</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out</span><span class="p">:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addrs</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="参考文章">参考文章</h3>
<p>[1]. Mccanne S , Jacobson V . The BSD Packet Filter: A New Architecture for User-level Packet Capture[C]// Proceedings of the USENIX Winter 1993 Conference Proceedings on USENIX Winter 1993 Conference Proceedings. USENIX Association, 1993.
[2]. A JIT for packet filters. <a href="https://lwn.net/Articles/437981/">https://lwn.net/Articles/437981/</a>.
[3]. net: filter: Just In Time compiler. <a href="https://lwn.net/Articles/437884/">https://lwn.net/Articles/437884/</a>.
[4]. Understanding JIT compiler (just-in-time compiler) for java. <a href="https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/">https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/</a>.</p>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%B7%A5%E5%85%B7/" term="linux工具" label="linux工具" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">The BSD Packet Filter论文笔记及源码解析</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/bpf-paper/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/bpf-paper/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-05-09T08:36:36+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[本文主要介绍了bpf论文和bpf源码。 简介 从下图可以看出，当网卡驱动接收到packet的时，一般情况下会直接传给协议栈。但是当bpf处于工作状态，驱动首先调用bpf程序……]]></summary>
            
                <content type="html"><![CDATA[<p>本文主要介绍了bpf论文和bpf源码。</p>
<h3 id="简介">简介</h3>
<p>从下图可以看出，当网卡驱动接收到packet的时，一般情况下会直接传给协议栈。但是当bpf处于工作状态，驱动首先调用bpf程序，bpf程序会执行与其绑定的filter程序。如果该packet通过过滤条件，将该packet拷贝到对应进程的buffer中。由此，bpf程序主要由两部分构成：</p>
<ol>
<li>network tap：将网卡驱动收到的packet传给监听的应用程序；</li>
<li>filter：过滤掉不需要的packet。</li>
</ol>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200509083958.png" alt=""></p>
<h3 id="network-tap">network tap</h3>
<p>网卡驱动一旦收到/发出packet，会先调用<code>bpf_tap</code>函数，下面是<code>bpf_tap</code>函数的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">bpf_tap</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">pktlen</span><span class="p">)</span>
	<span class="n">caddr_t</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">pkt</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">u_int</span> <span class="n">pktlen</span><span class="p">;</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bpf_if</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">bpf_d</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">u_int</span> <span class="n">slen</span><span class="p">;</span>
	<span class="c1">// arg是和特定网卡绑定的bpf_if，类似于net_if
</span><span class="c1"></span>	<span class="n">bp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bpf_if</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="c1">// 遍历所有的监听描述符，该描述符对应着一个进程
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bif_dlist</span><span class="p">;</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">bd_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">bd_rcount</span><span class="p">;</span>
		<span class="c1">// 执行每个描述符的过滤程序
</span><span class="c1"></span>		<span class="n">slen</span> <span class="o">=</span> <span class="n">bpf_filter</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">bd_filter</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">pktlen</span><span class="p">,</span> <span class="n">pktlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="c1">// 返回非0，将包传给该描述符，也就是拷贝到该描述符指定的buffer中；
</span><span class="c1"></span>            <span class="c1">// 1. bpf可以设置immediate参数，每次都唤醒该描述符对应的进程
</span><span class="c1"></span>            <span class="c1">// 2. 或者等缓冲区满的时候再唤醒该描述符对应的进程，该进程从缓冲区读取数据
</span><span class="c1"></span>			<span class="n">catchpacket</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">pktlen</span><span class="p">,</span> <span class="n">slen</span><span class="p">,</span> <span class="n">bcopy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="filter">filter</h3>
<p>filter是bpf实现比较关键的部分，作者首先提出了布尔表达式树和控制流图的方式来计算是否需要该packet，并指出在大部分情况下，控制流图的方式所需要的操作要少一些。</p>
<p>其次，作者自定义了一些伪机器码，该伪机器码同一般的机器码类似，但是不能够直接运行在真实的机器上，需要进行动态的翻译。</p>
<p>filter程序对应的机器模型由两个寄存器，分别是accumulator（记作A）和index register（记作x），下面列举了filter程序的指令格式、指令集及取址模式：</p>
<ul>
<li>指令格式：16bit的操作码，jt是jump true，jf是jump false。</li>
</ul>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200509095900.png" alt=""></p>
<ul>
<li>指令集：
<ul>
<li>ld类型指令：<code>ld,ldh,ldb</code>拷贝数值到寄存器<code>A</code>，<code>ldx</code>拷贝数值到寄存器<code>X</code>；下面是执行ld类型指令的流程；</li>
<li>alu类型指令（<code>add,sub...</code>）：使用寄存器<code>A</code>、立即数k、和寄存器<code>x</code>做运算，并将运算结果存储到寄存器<code>A</code>；</li>
<li>jump类型指令：比较寄存器<code>A</code>和操作数的值，根据是否相同做跳转；</li>
<li>存储类型指令：<code>st</code>拷贝数值到寄存器<code>A</code>，<code>stx</code>拷贝数值到寄存器<code>X</code>；</li>
<li>ret指令：表示结束，以及需要接收字节；</li>
<li>tax和txa指令：将寄存器值传递给另外一个寄存器；</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200509095351.png" alt=""></p>
<ul>
<li>取址模式
<ul>
<li>带<code>#</code>的表示数值在指令格式的k字段上；</li>
<li>M[k]：表示分配的临时内存中第k个字节；</li>
<li>[k]：packet的偏移地址为k上的数据；</li>
<li>L：当前指令所在的偏移地址；</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200509100321.png" alt=""></p>
<p>实例分析：</p>
<pre><code class="language-assembly" data-lang="assembly">	ldh [12]					# 加载packet偏移地址为12的半字到寄存器A，根据以太网包头部格式知道该半字表示以太网包中的数据类型
	jeq #ETHERPROTO_IP, L1, L5	# 比较A和ETHERPROTO_IP的值，相等去L1，不等去L5
L1: ldb [23]					# 加载packet偏移地址为23的字节到寄存器A
	jeq #IPPROTO_TCP, L2, L5	# 比较A和IPPROTO_TCP的值，相等去L2，不等去L5
L2: ldh [20]					# 加载packet偏移地址为20的半字到寄存器A
	jset #0x1fff, L5, L3		# A&amp;0x1fff是否为真，真去L5，假去L3
L3: ldx 4*([14]&amp;0xf)			# (packet[14]&amp;0xf)*4加载到寄存器X
	ldh [x+16]					# 加载packet偏移地址为x+16的半字到寄存器A
	jeq #N, L4, L5				# 比较port和N是否相等，相等去L4，不等去L5
L4: ret #TRUE					# 返回长度k
L5: ret #0						# 返回长度0
</code></pre><p>下面是动态翻译的源码，只给了几个示例注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">bpf_insn</span> <span class="p">{</span>
	<span class="n">u_short</span>	<span class="n">code</span><span class="p">;</span>	<span class="c1">// 操作码
</span><span class="c1"></span>	<span class="n">u_char</span> 	<span class="n">jt</span><span class="p">;</span>		<span class="c1">// jump ture 时对应的offset
</span><span class="c1"></span>	<span class="n">u_char</span> 	<span class="n">jf</span><span class="p">;</span>		<span class="c1">// jump false时对应的offset
</span><span class="c1"></span>	<span class="n">bpf_int32</span> <span class="n">k</span><span class="p">;</span>	<span class="c1">// 立即数
</span><span class="c1"></span><span class="p">};</span>

<span class="n">u_int</span>
<span class="nf">bpf_filter</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wirelen</span><span class="p">,</span> <span class="n">buflen</span><span class="p">)</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">wirelen</span><span class="p">;</span>
	<span class="k">register</span> <span class="n">u_int</span> <span class="n">buflen</span><span class="p">;</span>
<span class="p">{</span>
    <span class="c1">// 寄存器A,X
</span><span class="c1"></span>	<span class="k">register</span> <span class="n">u_int32</span> <span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
    <span class="c1">// scratch memory：临时内存空间
</span><span class="c1"></span>	<span class="n">int32</span> <span class="n">mem</span><span class="p">[</span><span class="n">BPF_MEMWORDS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/*
</span><span class="cm">		 * No filter means accept all.
</span><span class="cm">		 */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">--</span><span class="n">pc</span><span class="p">;</span>
    <span class="c1">// 遍历所有的伪指令
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">pc</span><span class="p">;</span>
        <span class="c1">// 判断操作码类别
</span><span class="c1"></span>		<span class="k">switch</span> <span class="p">(</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">default</span><span class="o">:</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>			<span class="n">abort</span><span class="p">();</span>
<span class="cp">#endif
</span><span class="cp"></span>        <span class="c1">// ret指令且指令k字段有效
</span><span class="c1"></span>		<span class="k">case</span> <span class="n">BPF_RET</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
		<span class="c1">// ret指令且寄存器A有效
</span><span class="c1"></span>		<span class="k">case</span> <span class="n">BPF_RET</span><span class="o">|</span><span class="nl">BPF_A</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="n">A</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="n">BPF_W</span><span class="o">|</span><span class="nl">BPF_ABS</span><span class="p">:</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>				<span class="kt">int</span> <span class="n">merr</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">A</span> <span class="o">=</span> <span class="n">m_xword</span><span class="p">((</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">merr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">merr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="p">}</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">EXTRACT_LONG</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="n">BPF_H</span><span class="o">|</span><span class="nl">BPF_ABS</span><span class="p">:</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>				<span class="kt">int</span> <span class="n">merr</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">A</span> <span class="o">=</span> <span class="n">m_xhalf</span><span class="p">((</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">merr</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="p">}</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">EXTRACT_SHORT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="n">BPF_B</span><span class="o">|</span><span class="nl">BPF_ABS</span><span class="p">:</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>				<span class="k">register</span> <span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
				<span class="k">register</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
				<span class="n">MINDEX</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
				<span class="n">A</span> <span class="o">=</span> <span class="n">mtod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">)[</span><span class="n">k</span><span class="p">];</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="p">}</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="n">BPF_W</span><span class="o">|</span><span class="nl">BPF_LEN</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">wirelen</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LDX</span><span class="o">|</span><span class="n">BPF_W</span><span class="o">|</span><span class="nl">BPF_LEN</span><span class="p">:</span>
			<span class="n">X</span> <span class="o">=</span> <span class="n">wirelen</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="n">BPF_W</span><span class="o">|</span><span class="nl">BPF_IND</span><span class="p">:</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>				<span class="kt">int</span> <span class="n">merr</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">A</span> <span class="o">=</span> <span class="n">m_xword</span><span class="p">((</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">merr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">merr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="p">}</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">EXTRACT_LONG</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="n">BPF_H</span><span class="o">|</span><span class="nl">BPF_IND</span><span class="p">:</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>				<span class="kt">int</span> <span class="n">merr</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">A</span> <span class="o">=</span> <span class="n">m_xhalf</span><span class="p">((</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">merr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">merr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="p">}</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">EXTRACT_SHORT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="n">BPF_B</span><span class="o">|</span><span class="nl">BPF_IND</span><span class="p">:</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>				<span class="k">register</span> <span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
				<span class="k">register</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
				<span class="n">MINDEX</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
				<span class="n">A</span> <span class="o">=</span> <span class="n">mtod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">)[</span><span class="n">k</span><span class="p">];</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="p">}</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LDX</span><span class="o">|</span><span class="n">BPF_MSH</span><span class="o">|</span><span class="nl">BPF_B</span><span class="p">:</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">buflen</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef KERNEL
</span><span class="cp"></span>				<span class="k">register</span> <span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
				<span class="k">register</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mbuf</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
				<span class="n">MINDEX</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
				<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">mtod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="p">}</span>
			<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="nl">BPF_IMM</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LDX</span><span class="o">|</span><span class="nl">BPF_IMM</span><span class="p">:</span>
			<span class="n">X</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_LD</span><span class="o">|</span><span class="nl">BPF_MEM</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_LDX</span><span class="o">|</span><span class="nl">BPF_MEM</span><span class="p">:</span>
			<span class="n">X</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="nl">BPF_ST</span><span class="p">:</span>
			<span class="n">mem</span><span class="p">[</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="nl">BPF_STX</span><span class="p">:</span>
			<span class="n">mem</span><span class="p">[</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="nl">BPF_JA</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JGT</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JGE</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JEQ</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JSET</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JGT</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;</span> <span class="n">X</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JGE</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="n">X</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JEQ</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">X</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_JMP</span><span class="o">|</span><span class="n">BPF_JSET</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">pc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">X</span><span class="p">)</span> <span class="o">?</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="nl">jt</span> <span class="p">:</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">jf</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_ADD</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">+=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_SUB</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">-=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_MUL</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">*=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_DIV</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">A</span> <span class="o">/=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_AND</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">&amp;=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_OR</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">|=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_LSH</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">&lt;&lt;=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_RSH</span><span class="o">|</span><span class="nl">BPF_X</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">&gt;&gt;=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_ADD</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">+=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_SUB</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">-=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_MUL</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">*=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_DIV</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">/=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_AND</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">&amp;=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
			
		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_OR</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">|=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_LSH</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">&lt;&lt;=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="n">BPF_RSH</span><span class="o">|</span><span class="nl">BPF_K</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">&gt;&gt;=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_ALU</span><span class="o">|</span><span class="nl">BPF_NEG</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_MISC</span><span class="o">|</span><span class="nl">BPF_TAX</span><span class="p">:</span>
			<span class="n">X</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BPF_MISC</span><span class="o">|</span><span class="nl">BPF_TXA</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="参考阅读">参考阅读</h3>
<p>[1]. Mccanne S , Jacobson V . The BSD Packet Filter: A New Architecture for User-level Packet Capture[C]// Proceedings of the USENIX Winter 1993 Conference Proceedings on USENIX Winter 1993 Conference Proceedings. USENIX Association, 1993.</p>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%B7%A5%E5%85%B7/" term="linux工具" label="linux工具" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Waitqueue简介</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/waitqueue/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/waitqueue/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-05-06T20:00:07+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[wait queue思想比较简单，但是涉及到的多核和锁的问题比较多，这些问题也很复杂，因此本文并不会涉及这些内容。本文主要梳理wait queue的基本思想，以及一些驱动程序如何……]]></summary>
            
                <content type="html"><![CDATA[<p>wait queue思想比较简单，但是涉及到的多核和锁的问题比较多，这些问题也很复杂，因此本文并不会涉及这些内容。本文主要梳理wait queue的基本思想，以及一些驱动程序如何使用wait queue，包括常见的epoll驱动和uio驱动。</p>
<p>文章<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>提出了filtered wakeups方法，该方法需要进程被加入到wait queue时提供一个key，同时wakeup唤醒时也需要传入一个key，通过比较key是否相同来决定唤醒哪一个进程。该方案主要用于解决大量的进程在等待同一事件时，一起唤醒会导致惊群效应（在此之前采用hash的方法，将事件进行hash来决定将进程加入哪个wait queue中，但是<a href="https://lwn.net/Articles/83635/">实验显示</a>hash方法很容易导致冲突，也会出现惊群效应）。</p>
<p>文章<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>提出在rt-kernel中使用simple wait queues，也就是当前的waitqueues机制中删除exclusive wakeup特性和回调函数特性，采用遍历的方法，一一唤醒每一个等待的进程。</p>
<p>文章<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>在文章<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>的基础上谈到了waitqueue中的custom  wakeup callbacks是否会被加入到rt-kernel中。其指出custom wakeup callbacks在IO复用中会有很大的好处，特别是poll、epoll和select。但是custom wakeup callbacks会带来的问题就是回调函数的执行时间无法确定，无法满足实时性的要求。而且custom wakeup callbacks需要使用spinlock，spinlock在rt-kernel内可休眠的。所以，在rt-kernel内引入custom wakeup callbacks是比较困难的。</p>
<h3 id="简介">简介</h3>
<p>wait queue采用双向链表的方式管理等待的进程，当事件发生的时候，会调用<code>wake up</code>函数，该函数会从等待队列中唤醒进程。<code>wait queue</code>主要提供了以下几个结构体和方法：</p>
<p><code>wait queue</code>主要提供了两个结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 队列元素
</span><span class="c1"></span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">private</span><span class="p">;</span>	<span class="c1">//等待进程
</span><span class="c1"></span>	<span class="n">wait_queue_func_t</span>	<span class="n">func</span><span class="p">;</span>	<span class="c1">//回调函数，用于唤醒进程，一般采用默认的default_wake_function
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">entry</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 队首，一个队首往往代表着一个事件，该队首代表的队列中的队列元素就是等待该事件发生的进程
</span><span class="c1"></span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">head</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><code>wait queue</code>主要提供了八个基本方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 创建一个新的wait queue entry，包含声明和初始化
</span><span class="c1"></span><span class="cp">#define DECLARE_WAITQUEUE(name, tsk)
</span><span class="cp"></span><span class="c1">// 创建一个新的wait queue，包含声明和初始化
</span><span class="c1"></span><span class="cp">#define DECLARE_WAIT_QUEUE_HEAD(name)
</span><span class="cp"></span><span class="c1">// 初始化wait queue
</span><span class="c1"></span><span class="cp">#define init_waitqueue_head(wq_head)
</span><span class="cp"></span><span class="c1">// 初始化wait queue entry
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>

<span class="c1">// 向wait queue添加wait queue entry
</span><span class="c1"></span><span class="kt">void</span> <span class="n">add_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
<span class="c1">// 向wait queue添加wait queue entry，该entry带有WQ_FLAG_EXCLUSIVE特性，防止惊群问题，导致性能下降
</span><span class="c1"></span><span class="kt">void</span> <span class="n">add_wait_queue_exclusive</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
<span class="c1">// 从wait queue移除一个entry，一般是唤醒之后的操作
</span><span class="c1"></span><span class="kt">void</span> <span class="n">remove_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
<span class="c1">// 遍历wait queue，唤醒nr_exclusive个进程：回调函数default_wake_function，调用关系比较复杂，主要是将该进程挂载到run_queue以及将其状态置为TASK_RUNNING
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">__wake_up_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">bookmark</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="历史">历史</h3>
<p>wait queue早期的策略比较简单。当事件发生时，调用<code>wake_up</code>函数唤醒所有的在该事件的阻塞进程。但是会有一个严重的问题，就是惊群问题。惊群问题是指多个被唤醒的进程竞争<strong>同一个临界资源</strong>。wait queue添加<code>exclusive wait</code>特性，使得每次只有一个进程被唤醒（如果不是临界资源可以不使用<code>exclusive wait</code>特性）。随着逐渐发展，wait queue变得越来越复杂，尤其是其回调函数</p>
<p>Waiting / Blocking in Linux Driver Part – 3 <a href="https://sysplay.in/blog/linux-kernel-internals/2015/12/waiting-blocking-in-linux-driver-part-3/">https://sysplay.in/blog/linux-kernel-internals/2015/12/waiting-blocking-in-linux-driver-part-3/</a></p>
<!-- 
### epoll wait queue的使用 -->
<h3 id="uio-wait-queue的使用">uio wait queue的使用</h3>
<p>uio使用wait queue机制完成向用户驱动通知某个中断号的中断事件，当用户驱动程序读<code>/proc/irq/irq num/irq</code>文件时，如果中断没有发生时会被阻塞。当中断发生时，中断处理函数会唤醒该进程：</p>
<pre><code>global wqh
global condition
func init
	register_irq(irq,irq_handler)
	wqh = init_wait_queue_head
	condition = false

func irq_handler
	condition = true
	wake_up(wqh)

func read:
	add_wait_queue(current, wqh)
	while
		set_current_state(TASK_INTERRUPTIBLE)
		if condition is true
			set_current_state(TASK_RUNNING)
			break
		schedule
	set_current_state(TASK_RUNNING)
	remove_wait_queue(current)
</code></pre><p>当调用<code>int __uio_register_device(struct module *owner, struct device *parent, struct uio_info *info)</code>函数注册一个uio驱动时，初始化该wait queue，并注册中断处理函数，下面是代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">__uio_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">uio_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
	<span class="k">struct</span> <span class="n">uio_device</span> <span class="o">*</span><span class="n">idev</span><span class="p">;</span>
	<span class="n">idev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">idev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="c1">// 初始化一个wait queue head
</span><span class="c1"></span>	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idev</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="c1">// wait queue head和中断事件绑定
</span><span class="c1"></span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">uio_interrupt</span><span class="p">,</span>
				  <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_flags</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">idev</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>用户驱动需要自己开一个单独的线程去接收中断事件，避免整个进程被阻塞。该线程通过读<code>/proc/irq/irq number/irq</code>文件，下面时读时执行的代码。流程如下：</p>
<ol>
<li>首先通过<code>add_wait_queue</code>将自己挂载到wait queue上；</li>
<li><code>set_current_state</code>将自己的状态设置为TASK_INTERRUPTIBLE，避免自己在事件没到来之前就被唤醒，导致无用的上下文切换；</li>
<li>当前仍然处于该进程的上下文，通过<code>event_count</code>是否增加来判断中断是否发生，如果发生了则重新将进程挂载到run queue，否则发起调度，等待通知，即<code>wake_up</code>；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">ssize_t</span> <span class="nf">uio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uio_listener</span> <span class="o">*</span><span class="n">listener</span> <span class="o">=</span> <span class="n">filep</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uio_device</span> <span class="o">*</span><span class="n">idev</span> <span class="o">=</span> <span class="n">listener</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="n">ssize_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">event_count</span><span class="p">;</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idev</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="c1">// 将当前进程状态设置为TASK_INTERRUPTIBLE，可被信号唤醒
</span><span class="c1"></span>		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="c1">// 读取当前事件次数
</span><span class="c1"></span>		<span class="n">event_count</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idev</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event_count</span> <span class="o">!=</span> <span class="n">listener</span><span class="o">-&gt;</span><span class="n">event_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 说明发生了新的事件，可以通知进程去处理
</span><span class="c1"></span>			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_count</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">listener</span><span class="o">-&gt;</span><span class="n">event_count</span> <span class="o">=</span> <span class="n">event_count</span><span class="p">;</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// 如果是非阻塞读，则直接返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">filep</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// 被信号唤醒
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// 调度，等待irq_handler将自己唤醒
</span><span class="c1"></span>		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="c1">// 发生新的事件，将进程挂载到run queue
</span><span class="c1"></span>	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="c1">// 将该进程从wait queue移除
</span><span class="c1"></span>	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idev</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因为是捕捉中断事件，所以需要像该中断号注册中断处理函数，然后在中断处理函数中唤醒wait queue上的等待进程。中断处理函数注册是在<code>__uio_register_device</code>函数完成的，下面我们关注中断发生时中断处理函数的动作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">uio_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uio_device</span> <span class="o">*</span><span class="n">idev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uio_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="c1">// 增加中断发生的次数，因为在wake_up后，进程是通过event次数来判断是否发生中断
</span><span class="c1"></span>	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idev</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
	<span class="c1">// 唤醒该进程
</span><span class="c1"></span>	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idev</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="使用wait-queue提供的wait_events">使用wait queue提供的wait_events</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/errno.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;asm/uaccess.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/wait.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/delay.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define FIRST_MINOR 0
</span><span class="cp">#define MINOR_CNT 1
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">flag</span> <span class="o">=</span> <span class="sc">&#39;n&#39;</span><span class="p">;</span>
<span class="k">static</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cdev</span> <span class="n">c_dev</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">cl</span><span class="p">;</span>
<span class="k">static</span> <span class="nf">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;Inside open</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;Inside close</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offp</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;Inside read</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;Scheduling Out</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">flag</span> <span class="o">==</span> <span class="sc">&#39;y&#39;</span><span class="p">);</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="sc">&#39;n&#39;</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;Woken Up</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offp</span><span class="p">)</span> 
<span class="p">{</span>   
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;Inside write</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file_operations</span> <span class="n">pra_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="nl">read</span><span class="p">:</span>        <span class="n">read</span><span class="p">,</span>
	<span class="nl">write</span><span class="p">:</span>       <span class="n">write</span><span class="p">,</span>
	<span class="nl">open</span><span class="p">:</span>        <span class="n">open</span><span class="p">,</span>
	<span class="nl">release</span><span class="p">:</span>     <span class="n">release</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">wq_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev_ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="n">FIRST_MINOR</span><span class="p">,</span> <span class="n">MINOR_CNT</span><span class="p">,</span> <span class="s">&#34;SCD&#34;</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&#34;Major Nr: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pra_fops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_CNT</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_CNT</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cl</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&#34;chardrv&#34;</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">);</span>
		<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_CNT</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev_ret</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&#34;mychar%d&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">class_destroy</span><span class="p">(</span><span class="n">cl</span><span class="p">);</span>
		<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">);</span>
		<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_CNT</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev_ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wq_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;Inside cleanup_module</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="n">device_destroy</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">cl</span><span class="p">);</span>
	<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_dev</span><span class="p">);</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MINOR_CNT</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">wq_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">wq_cleanup</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&#34;GPL&#34;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&#34;Pradeep&#34;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&#34;Waiting Process Demo&#34;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="参考文献">参考文献</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Filtered wakeups. <a href="https://lwn.net/Articles/83633/">https://lwn.net/Articles/83633/</a>. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Simple wait queues. <a href="https://lwn.net/Articles/577370/">https://lwn.net/Articles/577370/</a>. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>The return of simple wait queues. <a href="https://lwn.net/Articles/661424/">https://lwn.net/Articles/661424/</a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Lab5 - 实验笔记</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/course/mit6828/lab5/" />
            <id>https://chengshuyi.github.io/posts/course/mit6828/lab5/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-25T13:34:18+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[文件系统架构 在init.c通过ENV_CREATE(fs_fs, ENV_TYPE_FS);创建一个专用于文件系统的进程，该进程提供了文件系统的管理，包括读取文件、写入文……]]></summary>
            
                <content type="html"><![CDATA[<h3 id="文件系统架构">文件系统架构</h3>
<p>在<code>init.c</code>通过<code>ENV_CREATE(fs_fs, ENV_TYPE_FS);</code>创建一个专用于文件系统的进程，该进程提供了文件系统的管理，包括读取文件、写入文件等等；</p>
<p>假设有其他的进程需要进行文件读取，则需要通过ipc（inter process call）的方式将读取文件的元信息传递文件系统进程；</p>
<p>以打开文件为例，具体代码流程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 库提供的open函数
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Fd</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
	<span class="c1">// fd_alloc利用之前的自映射快速找到用户进程空间未使用的struct Fd空间。（通过判断虚拟地址对应的表项是否存在）
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">fd_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="c1">// ipc参数
</span><span class="c1"></span>	<span class="n">strcpy</span><span class="p">(</span><span class="n">fsipcbuf</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">req_path</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="n">fsipcbuf</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">req_omode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="c1">// fsipc的信息传递，具体看下面
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">fsipc</span><span class="p">(</span><span class="n">FSREQ_OPEN</span><span class="p">,</span> <span class="n">fd</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fd_close</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fd2num</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// file system对jos提供的ipc机制的封装，主要是传递的参数格式化
</span><span class="c1">// type是操作类型，比如FSREQ_OPEN
</span><span class="c1">// dstva是struct Fd的虚拟地址
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">fsipc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dstva</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">envid_t</span> <span class="n">fsenv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsenv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">// 利用子映射快速遍历所有的env，找到文件系统对应的env（ipc通信需要的参数）
</span><span class="c1"></span>		<span class="n">fsenv</span> <span class="o">=</span> <span class="n">ipc_find_env</span><span class="p">(</span><span class="n">ENV_TYPE_FS</span><span class="p">);</span>
    <span class="c1">// ipc
</span><span class="c1"></span>	<span class="n">ipc_send</span><span class="p">(</span><span class="n">fsenv</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsipcbuf</span><span class="p">,</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ipc_recv</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dstva</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">      <span class="n">Regular</span> <span class="n">env</span>           <span class="n">FS</span> <span class="n">env</span>
   <span class="o">+---------------+</span>   <span class="o">+---------------+</span>
   <span class="o">|</span>      <span class="n">read</span>     <span class="o">|</span>   <span class="o">|</span>   <span class="n">file_read</span>   <span class="o">|</span>
   <span class="o">|</span>   <span class="p">(</span><span class="n">lib</span><span class="o">/</span><span class="n">fd</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>  <span class="o">|</span>   <span class="o">|</span>   <span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>   <span class="o">|</span>
<span class="p">...</span><span class="o">|</span><span class="p">.......</span><span class="o">|</span><span class="p">.......</span><span class="o">|</span><span class="p">...</span><span class="o">|</span><span class="p">.......</span><span class="o">^</span><span class="p">.......</span><span class="o">|</span><span class="p">...............</span>
   <span class="o">|</span>       <span class="n">v</span>       <span class="o">|</span>   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span> <span class="n">RPC</span> <span class="n">mechanism</span>
   <span class="o">|</span>  <span class="n">devfile_read</span> <span class="o">|</span>   <span class="o">|</span>  <span class="n">serve_read</span>   <span class="o">|</span>
   <span class="o">|</span>  <span class="p">(</span><span class="n">lib</span><span class="o">/</span><span class="n">file</span><span class="p">.</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span>   <span class="o">|</span>  <span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="n">serv</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>  <span class="o">|</span>
   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span>   <span class="o">|</span>       <span class="o">^</span>       <span class="o">|</span>
   <span class="o">|</span>       <span class="n">v</span>       <span class="o">|</span>   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span>
   <span class="o">|</span>     <span class="n">fsipc</span>     <span class="o">|</span>   <span class="o">|</span>     <span class="n">serve</span>     <span class="o">|</span>
   <span class="o">|</span>  <span class="p">(</span><span class="n">lib</span><span class="o">/</span><span class="n">file</span><span class="p">.</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span>   <span class="o">|</span>  <span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="n">serv</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>  <span class="o">|</span>
   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span>   <span class="o">|</span>       <span class="o">^</span>       <span class="o">|</span>
   <span class="o">|</span>       <span class="n">v</span>       <span class="o">|</span>   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span>
   <span class="o">|</span>   <span class="n">ipc_send</span>    <span class="o">|</span>   <span class="o">|</span>   <span class="n">ipc_recv</span>    <span class="o">|</span>
   <span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span>   <span class="o">|</span>       <span class="o">^</span>       <span class="o">|</span>
   <span class="o">+-------|-------+</span>   <span class="o">+-------|-------+</span>
           <span class="o">|</span>                   <span class="o">|</span>
           <span class="o">+-------------------+</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="spawn">spawn</h3>
<p>spawn是创建进程的另外一种方式，它不同于fork。fork的话是创建和自身一样的运行环境，程序代码也是当前运行的程序代码。而spawn则是从文件系统加载一段新的程序代码去运行。spwan的具体流程如下：</p>
<ol>
<li>加载程序代码到内存中（从文件系统读取程序代码）；</li>
<li>创建子进程；</li>
</ol>
<h3 id="shell">shell</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">Pipe</span> <span class="p">{</span>
	<span class="n">off_t</span> <span class="n">p_rpos</span><span class="p">;</span>		<span class="c1">// read position
</span><span class="c1"></span>	<span class="n">off_t</span> <span class="n">p_wpos</span><span class="p">;</span>		<span class="c1">// write position
</span><span class="c1"></span>	<span class="n">uint8_t</span> <span class="n">p_buf</span><span class="p">[</span><span class="n">PIPEBUFSIZ</span><span class="p">];</span>	<span class="c1">// data buffer
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Dev</span> <span class="n">devpipe</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">dev_id</span> <span class="o">=</span>	<span class="sc">&#39;p&#39;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span> <span class="o">=</span>	<span class="s">&#34;pipe&#34;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_read</span> <span class="o">=</span>	<span class="n">devpipe_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_write</span> <span class="o">=</span>	<span class="n">devpipe_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_close</span> <span class="o">=</span>	<span class="n">devpipe_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_stat</span> <span class="o">=</span>	<span class="n">devpipe_stat</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 分开的命令分别进行spawn出新的进程去处理
</span><span class="c1"></span>		<span class="k">case</span> <span class="sc">&#39;|&#39;</span><span class="o">:</span>	
			<span class="c1">// 分配出两个fd,绑定的文件是devpipe
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;pipe: %e&#34;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
				<span class="n">exit</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="c1">// 创建子进程
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;fork: %e&#34;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
				<span class="n">exit</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 子进程
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 0是stdin，将pipe的第一个fd变成子进程的stdin
</span><span class="c1"></span>					<span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
                    <span class="c1">// 释放pipe的fd
</span><span class="c1"></span>					<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="p">}</span>
                <span class="c1">// 释放pipe的fd
</span><span class="c1"></span>				<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 当前进程
</span><span class="c1"></span>				<span class="n">pipe_child</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 将pipe的第二个fd变成当前进程的stdout
</span><span class="c1"></span>					<span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="p">}</span>
				<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">goto</span> <span class="n">runit</span><span class="p">;</span>
			<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 1.</strong> <code>i386_init</code> identifies the file system environment by passing the type <code>ENV_TYPE_FS</code> to your environment creation function, <code>env_create</code>. Modify <code>env_create</code> in <code>env.c</code>, so that it gives the file system environment I/O privilege, but never gives that privilege to any other environment.</p>
</blockquote>
<p>标记不同env的类型，文件系统的env类型是<code>ENV_TYPE_FS</code>。修改flags让用户模式的程序可以使用io特权指令。</p>
<!-- The x86 processor uses the IOPL bits in the EFLAGS register **to determine whether protected-mode code is allowed to perform special device I/O instructions such as the IN and OUT instructions.** Since all of the IDE disk registers we need to access are located in the x86's I/O space rather than being memory-mapped, **giving "I/O privilege" to the file system environment is the only thing we need to do in order to allow the file system to access these registers**. In effect, the IOPL bits in the EFLAGS register provides the kernel with a simple "all-or-nothing" method of controlling whether user-mode code can access I/O space. In our case, we want the file system environment to be able to access I/O space, but we do not want any other environments to be able to access I/O space at all. -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">env_create</span><span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="n">binary</span><span class="p">,</span> <span class="k">enum</span> <span class="n">EnvType</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// lab3
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">;</span>
	<span class="n">env_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">env</span><span class="o">-&gt;</span><span class="n">env_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">load_icode</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">binary</span><span class="p">);</span>
    <span class="c1">// lab5
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">ENV_TYPE_FS</span><span class="p">){</span>
		<span class="n">env</span><span class="o">-&gt;</span><span class="n">env_type</span> <span class="o">=</span> <span class="n">ENV_TYPE_FS</span><span class="p">;</span>
		<span class="n">env</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">.</span><span class="n">tf_eflags</span> <span class="o">|=</span> <span class="n">FL_IOPL_MASK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 2.</strong> Implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in <code>fs/bc.c</code>. <code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, except that its job is to load pages in from the disk in response to a page fault. When writing this, keep in mind that (1) <code>addr</code> may not be aligned to a block boundary and (2) <code>ide_read</code> operates in sectors, not blocks.</p>
</blockquote>
<p>硬盘的数据在内存中叫block cache，jos分配了固定的虚拟地址空间存放硬盘数据，当我们需要读写的时候，如果该数据在内存中不存在，则会触发异常，该异常由内核传递给用户程序处理，即<code>bc_pgfault</code>函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// static void bc_pgfault(struct UTrapframe *utf)
</span><span class="c1"></span>	<span class="c1">// 地址对齐
</span><span class="c1"></span>	<span class="n">addr</span> <span class="o">=</span> <span class="n">ROUNDDOWN</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="n">BLKSIZE</span><span class="p">);</span>
	<span class="c1">// 分配一个page的物理内存
</span><span class="c1"></span>	<span class="k">if</span><span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sys_page_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span><span class="n">PTE_SYSCALL</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&#34;in bc_pgfault, sys_page_alloc: %e&#34;</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
	<span class="c1">// 读取磁盘数据到内存中
</span><span class="c1"></span>	<span class="k">if</span><span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">ide_read</span><span class="p">(((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">addr</span><span class="o">-</span><span class="n">DISKMAP</span><span class="p">)</span><span class="o">/</span><span class="n">BLKSIZE</span><span class="o">*</span><span class="n">BLKSECTS</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">BLKSECTS</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&#34;in bc_pgfault, ide_read: %e&#34;</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>flush_block</code>主要是维持内存和硬盘中的数据同步。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// void flush_block(void *addr)	
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">ROUNDDOWN</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="n">BLKSIZE</span><span class="p">);</span>
	<span class="c1">// 该地址对应的block存在内存中，并且有修改过（没有修改的话就不用flush）。
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">va_is_mapped</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">va_is_dirty</span><span class="p">(</span><span class="n">addr</span><span class="p">)){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">ide_write</span><span class="p">(</span><span class="n">blockno</span><span class="o">*</span><span class="n">BLKSECTS</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">BLKSECTS</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&#34;in flush_block, ide_write %e&#34;</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
        <span class="c1">// 清除dirty位
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">sys_page_map</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">uvpt</span><span class="p">[</span><span class="n">PGNUM</span><span class="p">(</span><span class="n">addr</span><span class="p">)]</span> <span class="o">&amp;</span> <span class="n">PTE_SYSCALL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&#34;in flush_block, sys_page_map: %e&#34;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 3.</strong> Use <code>free_block</code> as a model to implement <code>alloc_block</code> in <code>fs/fs.c</code>, which should find a free disk block in the bitmap, mark it used, and return the number of that block. When you allocate a block, you should immediately flush the changed bitmap block to disk with <code>flush_block</code>, to help file system consistency.</p>
</blockquote>
<p>从硬盘空闲块中分配一块，返回块号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//int alloc_block(void)
</span><span class="c1"></span>	<span class="n">uint32_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_nblocks</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">block_is_free</span><span class="p">(</span><span class="n">i</span><span class="p">)){</span>
			<span class="n">bitmap</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">32</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">32</span><span class="p">));</span>
            <span class="c1">// 将bitmap数据flush到硬盘，防止断电等意外发生，造成数据的丢失
</span><span class="c1"></span>			<span class="n">flush_block</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="o">/</span><span class="n">BLKBITSIZE</span><span class="p">)</span><span class="o">*</span><span class="n">BLKSIZE</span><span class="o">+</span><span class="n">DISKMAP</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 4.</strong> Implement <code>file_block_walk</code> and <code>file_get_block</code>. <code>file_block_walk</code> maps from a block offset within a file to the pointer for that block in the <code>struct File</code> or the indirect block, very much like what <code>pgdir_walk</code> did for page tables. <code>file_get_block</code> goes one step further and maps to the actual disk block, allocating a new one if necessary.</p>
</blockquote>
<p>jos文件系统采用类似于inode的方式，每个文件数据对应的物理存储块编号采用直接方式和间接方式。直接索引就是将该存储块编号存放在inode的数组中，间接索引是将该存储块编号存放在block中。<code>file_block_walk</code>函数将文件的逻辑地址转换成对应的硬盘上的物理地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//static int file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)
</span><span class="c1"></span>	<span class="n">uintptr_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="c1">// 逻辑块号小于NDIRECT
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">filebno</span> <span class="o">&lt;</span> <span class="n">NDIRECT</span><span class="p">){</span>
		<span class="o">*</span><span class="n">ppdiskbno</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_direct</span><span class="p">[</span><span class="n">filebno</span><span class="p">];</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="c1">// 超过文件最大限制
</span><span class="c1"></span>		<span class="k">if</span><span class="p">(</span><span class="n">filebno</span> <span class="o">&gt;=</span> <span class="n">NDIRECT</span> <span class="o">+</span> <span class="n">NINDIRECT</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E_INVAL</span><span class="p">;</span>
        <span class="c1">// 间接存储的block还未分配
</span><span class="c1"></span>		<span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_indirect</span><span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">block_is_free</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_indirect</span><span class="p">)){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">alloc</span><span class="p">){</span>
                <span class="c1">// 分配一个block用于存储物理存储块编号
</span><span class="c1"></span>				<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_indirect</span> <span class="o">=</span> <span class="n">alloc_block</span><span class="p">();</span>
				<span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_indirect</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
					<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_indirect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">E_NO_DISK</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span><span class="k">else</span><span class="p">{</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E_NOT_FOUND</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 获取间接索引的物理存储块（一般会触发上面的bc_pgfault）
</span><span class="c1"></span>	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">uintptr_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_indirect</span><span class="o">*</span><span class="n">BLKSIZE</span><span class="o">+</span><span class="n">DISKMAP</span><span class="p">);</span>
	<span class="c1">// 物理块号
</span><span class="c1"></span>	<span class="o">*</span><span class="n">ppdiskbno</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">[</span><span class="n">filebno</span><span class="o">-</span><span class="n">NDIRECT</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// int file_get_block(struct File *f, uint32_t filebno, char **blk)
</span><span class="c1"></span>	<span class="c1">// LAB 5: Your code here.
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">uint32_t</span> <span class="o">*</span><span class="n">ppdiskbno</span><span class="p">;</span>
	<span class="c1">// 找到逻辑块号对应的物理块号
</span><span class="c1"></span>	<span class="k">if</span><span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">file_block_walk</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">filebno</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ppdiskbno</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 物理块不存在，需要分配一个物理块给当前文件
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">ppdiskbno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
		<span class="o">*</span><span class="n">ppdiskbno</span> <span class="o">=</span> <span class="n">alloc_block</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">ppdiskbno</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E_NO_DISK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 返回该物理块映射的虚拟地址
</span><span class="c1"></span>	<span class="o">*</span><span class="n">blk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">diskaddr</span><span class="p">(</span><span class="o">*</span><span class="n">ppdiskbno</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 5.</strong> Implement <code>serve_read</code> in <code>fs/serv.c</code>.</p>
<p><code>serve_read</code>'s heavy lifting will be done by the already-implemented <code>file_read</code> in <code>fs/fs.c</code> (which, in turn, is just a bunch of calls to <code>file_get_block</code>). <code>serve_read</code> just has to provide the RPC interface for file reading. Look at the comments and code in <code>serve_set_size</code> to get a general idea of how the server functions should be structured.</p>
</blockquote>
<p>前面几个函数是涉及到文件系统到硬盘的管理，下面的则是完成用户的请求。<code>serve_read</code>函数接收用户进程的Fsipc</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//int serve_read(envid_t envid, union Fsipc *ipc)
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">OpenFile</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="c1">// 检查该进程的打开文件列表是否存在该文件
</span><span class="c1"></span>	<span class="k">if</span><span class="p">((</span><span class="n">r</span><span class="o">=</span><span class="n">openfile_lookup</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req_fileid</span><span class="p">,</span><span class="o">&amp;</span><span class="n">o</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 读取文件数据（通过bc_pgfault的方式实现）
</span><span class="c1"></span>	<span class="n">r</span> <span class="o">=</span> <span class="n">file_read</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">o_file</span><span class="p">,</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">ret_buf</span><span class="p">,</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req_n</span><span class="p">,</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">o_fd</span><span class="o">-&gt;</span><span class="n">fd_offset</span><span class="p">);</span>
	<span class="c1">// 修改seek位置
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">o_fd</span><span class="o">-&gt;</span><span class="n">fd_offset</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 6.</strong> Implement <code>serve_write</code> in <code>fs/serv.c</code> and <code>devfile_write</code> in <code>lib/file.c</code>.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// int serve_write(envid_t envid, struct Fsreq_write *req)
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">OpenFile</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="c1">// 检查该进程的打开文件列表是否存在该文件
</span><span class="c1"></span>	<span class="k">if</span><span class="p">((</span><span class="n">r</span><span class="o">=</span><span class="n">openfile_lookup</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req_fileid</span><span class="p">,</span><span class="o">&amp;</span><span class="n">o</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">file_write</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">o_file</span><span class="p">,</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req_buf</span><span class="p">,</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req_n</span> <span class="o">&gt;</span> <span class="n">PGSIZE</span><span class="o">?</span> <span class="nl">PGSIZE</span><span class="p">:</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">req_n</span><span class="p">,</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">o_fd</span><span class="o">-&gt;</span><span class="n">fd_offset</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">o_fd</span><span class="o">-&gt;</span><span class="n">fd_offset</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// static ssize_t devfile_read(struct Fd *fd, void *buf, size_t n)	
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">fsipcbuf</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">req_buf</span><span class="p">))</span> 
		<span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">fsipcbuf</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">req_buf</span><span class="p">);</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">fsipcbuf</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">req_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">fsipcbuf</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">req_fileid</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_file</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
	<span class="n">fsipcbuf</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">req_n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">return</span> <span class="nf">fsipc</span><span class="p">(</span><span class="n">FSREQ_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 7.</strong> <code>spawn</code> relies on the new syscall <code>sys_env_set_trapframe</code> to initialize the state of the newly created environment. Implement <code>sys_env_set_trapframe</code> in <code>kern/syscall.c</code> (don't forget to dispatch the new system call in <code>syscall()</code>).</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// static int sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)	
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">envid2env</span><span class="p">(</span><span class="n">envid</span><span class="p">,</span><span class="o">&amp;</span><span class="n">e</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E_BAD_ENV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">user_mem_assert</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Trapframe</span><span class="p">),</span> <span class="n">PTE_U</span><span class="p">);</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">env_tf</span> <span class="o">=</span> <span class="o">*</span><span class="n">tf</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">.</span><span class="n">tf_eflags</span> <span class="o">|=</span> <span class="n">FL_IF</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">.</span><span class="n">tf_eflags</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">FL_IOPL_MASK</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 8.</strong> Change <code>duppage</code> in <code>lib/fork.c</code> to follow the new convention. If the page table entry has the <code>PTE_SHARE</code> bit set, just copy the mapping directly. (You should use <code>PTE_SYSCALL</code>, not <code>0xfff</code>, to mask out the relevant bits from the page table entry. <code>0xfff</code> picks up the accessed and dirty bits as well.)</p>
<p>Likewise, implement <code>copy_shared_pages</code> in <code>lib/spawn.c</code>. It should loop through all page table entries in the current process (just like <code>fork</code> did), copying any page mappings that have the <code>PTE_SHARE</code> bit set into the child process.</p>
</blockquote>
<p>spawn的话可以从用户态加载应用程序去运行。</p>
<blockquote>
<p><strong>Exercise 9.</strong> In your kern/trap.c, call kbd_intr to handle trap IRQ_OFFSET+IRQ_KBD and serial_intr to handle trap IRQ_OFFSET+IRQ_SERIAL.</p>
</blockquote>
<p><code>kbd_intr</code>函数读取键盘的输入；<code>serial_intr</code>函数读取输入的数据到buffer里面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">		<span class="k">case</span> <span class="n">IRQ_OFFSET</span><span class="o">+</span><span class="nl">IRQ_KBD</span><span class="p">:{</span>
			<span class="n">kbd_intr</span><span class="p">();</span>
			<span class="n">lapic_eoi</span><span class="p">();</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 10.</strong> The shell doesn't support I/O redirection. It would be nice to run sh &lt;script instead of having to type in all the commands in the script by hand, as you did above. Add I/O redirection for &lt; to user/sh.c.</p>
</blockquote>
<p>io重定向：以重定向输入为例（比如<code>sh&lt;script</code>）。因为fd 0代表着stdin，fd 1代表着stdout，所以将待重定向的文件的fd拷贝到子进程的fd 0即可（执行<code>sh</code>的shell可以通过<code>getchar</code>的方式读取该文件内容【根据fd绑定的内容找到对应的<code>devfile</code>，那么<code>getchar</code>的读取转换成<code>devfile-&gt;read</code>】）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">			<span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;open %s for read: %e&#34;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
				<span class="n">exit</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
				<span class="n">dup</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
				<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Lab4 - 实验笔记</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/course/mit6828/lab4/" />
            <id>https://chengshuyi.github.io/posts/course/mit6828/lab4/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-25T13:34:16+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[lab4 实验代码：不过最后primes案例没过 lab4实验代码patch1：通过primes案例 lab4实验代码patch2：小bug x86多核系统 JOS支持的是对称多处理器……]]></summary>
            
                <content type="html"><![CDATA[<p><a href="https://github.com/chengshuyi/jos-lab/commit/287d90ad016d0dbb6d1d275336c4007cc5c14931">lab4 实验代码：不过最后primes案例没过</a></p>
<p><a href="https://github.com/chengshuyi/jos-lab/commit/d108ac413223571d2417293fe5ce66bda8ca3920">lab4实验代码patch1：通过primes案例</a></p>
<p><a href="https://github.com/chengshuyi/jos-lab/commit/77e886ae1aeb99c42b604ec0b40bd9e05eb291a0">lab4实验代码patch2：小bug</a></p>
<h3 id="x86多核系统">x86多核系统</h3>
<p>JOS支持的是对称多处理器架构，最先启动的核称为bootstrap处理器（BSP），后续启动的核称为application处理器（APs）。下面介绍一下整个的启动流程：</p>
<ol>
<li>
<p><code>mp_init</code>函数：从BIOS中找到多处理器信息配置表；</p>
</li>
<li>
<p><code>boot_aps</code>函数：</p>
<p>a. 将APs的启动代码移动到0x7000的位置；</p>
<p>b. 发送核间中断，参数包括：cpu编号和cpu起始运行地址；</p>
<p>c. 等待该cpu启动完毕；</p>
</li>
<li>
<p>APs执行的代码和BSP差不太多，主要涉及的文件有：<code>kern/mpentry.S</code>和<code>kern/init.c</code>。</p>
</li>
</ol>
<h3 id="per-cpu">per-cpu</h3>
<p>per-cpu表示的是为每个cpu维护自己的数据结构，其次访问cpu共享的数据结构时需要加锁。</p>
<h3 id="copy-on-write">copy on write</h3>
<p>利用系统调用实现在用户态创建一个新的进程，也就是<code>fork</code>的方式，jos有两种实现方式，一种是dump_fork实现的，即在fork时为新进程分配内存；另外一种是基于copy-on-write的方式，即将父进程和子进程的页表项置为COW，在修改该页表项对应的物理页时会触发page fault异常，有该异常处理函数分配具体内存；</p>
<blockquote>
<p><strong>Exercise 1.</strong> Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">mmio_map_region</span><span class="p">(</span><span class="n">physaddr_t</span> <span class="n">pa</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">uintptr_t</span> <span class="n">base</span> <span class="o">=</span> <span class="n">MMIOBASE</span><span class="p">;</span>
    <span class="c1">// 大小取整
</span><span class="c1"></span>	<span class="n">size</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">PGSIZE</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MMIOLIM</span><span class="p">)</span> <span class="n">panic</span><span class="p">(</span><span class="s">&#34;error&#34;</span><span class="p">);</span>
    <span class="c1">// 做映射
</span><span class="c1"></span>	<span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span><span class="n">base</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">pa</span><span class="p">,</span><span class="n">PTE_PCD</span><span class="o">|</span><span class="n">PTE_PWT</span><span class="o">|</span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_P</span><span class="p">);</span>
	<span class="n">base</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">base</span><span class="o">-</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 2.</strong> Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code> to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	<span class="k">extern</span> <span class="kt">char</span> <span class="n">mpentry_start</span><span class="p">[];</span>
	<span class="k">extern</span> <span class="kt">char</span> <span class="n">mpentry_end</span><span class="p">[];</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">MPENTRY_PADDR</span><span class="p">;</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">mpentry_end</span><span class="o">-</span><span class="n">mpentry_start</span><span class="o">+</span><span class="n">s</span><span class="p">;</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">ROUNDDOWN</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">PGSIZE</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">PGSIZE</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">PGNUM</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">PGNUM</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">s</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">e</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 3.</strong> Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 将每个cpu的内核栈映射到指定的虚拟地址上
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_init_mp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">uintptr_t</span> <span class="n">s</span> <span class="o">=</span> <span class="n">KSTACKTOP</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NCPU</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span><span class="n">s</span><span class="o">-</span><span class="n">KSTKSIZE</span><span class="p">,</span><span class="n">KSTKSIZE</span><span class="p">,</span><span class="n">PADDR</span><span class="p">(</span><span class="n">percpu_kstacks</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_P</span><span class="p">);</span>
		<span class="n">s</span> <span class="o">-=</span> <span class="n">KSTKSIZE</span><span class="o">+</span><span class="n">KSTKGAP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 4.</strong> The code in <code>trap_init_percpu()</code> (<code>kern/trap.c</code>) initializes the TSS and TSS descriptor for the BSP.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">trap_init_percpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Setup a TSS so that we get the right stack
</span><span class="c1"></span>	<span class="c1">// when we trap to the kernel.
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">.</span><span class="n">ts_esp0</span> <span class="o">=</span> <span class="n">KSTACKTOP</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_id</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">.</span><span class="n">ts_esp0</span> <span class="o">-=</span> <span class="p">(</span><span class="n">KSTKSIZE</span><span class="o">+</span><span class="n">KSTKGAP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">.</span><span class="n">ts_ss0</span> <span class="o">=</span> <span class="n">GD_KD</span><span class="p">;</span>
	<span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">.</span><span class="n">ts_iomb</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Taskstate</span><span class="p">);</span>

	<span class="c1">// Initialize the TSS slot of the gdt.
</span><span class="c1"></span>	<span class="n">gdt</span><span class="p">[(</span><span class="n">GD_TSS0</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">SEG16</span><span class="p">(</span><span class="n">STS_T32A</span><span class="p">,</span> <span class="p">(</span><span class="n">uint32_t</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_ts</span><span class="p">),</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Taskstate</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gdt</span><span class="p">[(</span><span class="n">GD_TSS0</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">thiscpu</span><span class="o">-&gt;</span><span class="n">cpu_id</span><span class="p">].</span><span class="n">sd_s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Load the TSS selector (like other segment selectors, the
</span><span class="c1"></span>	<span class="c1">// bottom three bits are special; we leave them 0)
</span><span class="c1"></span>	<span class="n">ltr</span><span class="p">(</span><span class="n">GD_TSS0</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">));</span>

	<span class="c1">// Load the IDT
</span><span class="c1"></span>	<span class="n">lidt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idt_pd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 5.</strong> Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p>
</blockquote>
<p>实现大内核锁。</p>
<blockquote>
<p><strong>Exercise 6.</strong> Implement round-robin scheduling in <code>sched_yield()</code> as described above.</p>
</blockquote>
<p>实现轮转法调度。</p>
<blockquote>
<p><strong>Exercise 7.</strong> Implement the system calls described above in <code>kern/syscall.c</code> and make sure <code>syscall()</code> calls them. You will need to use various functions in <code>kern/pmap.c</code> and <code>kern/env.c</code>, particularly <code>envid2env()</code>.</p>
</blockquote>
<p>实现<code>sys_exofork</code>、<code>sys_env_set_status</code>、<code>sys_page_alloc</code>、<code>sys_page_map</code>和<code>sys_page_unmap</code>函数。</p>
<h3 id="copy-on-write-fork">Copy-on-Write Fork</h3>
<p>下面是用户空间出现页异常处理流程：</p>
<ol>
<li>通过系统调用注册进程自己的处理函数（在fork的时候配置的）；</li>
<li>当页异常触发时，首先由内核异常处理函数处理，判断该错误地址是否发生在用户地址空间。如果是的话则将进程的esp指向进程异常栈；将错误信息保存在进程异常栈（在fork的时候分配的内存）里；将返回值指向进程异常处理函数；</li>
<li>返回用户空间运行。</li>
</ol>
<p>下面是fork的流程：</p>
<ol>
<li>通过系统调用注册进程自己的处理函数；</li>
<li>通过系统调用创建子进程；</li>
<li>利用自映射机制可以快速遍历页表项，查看每个页表项的属性（低12位），如果该页存在的话，则将其映射到子进程的地址空间，并将其页表项型属性置为COW；然后修改自身的页表项的属性；（因为子进程和父进程都不能直接修改该页表项对应的物理页（原物理页），只能新建物理页并元物理页的内容拷贝进去。）</li>
<li>为子进程分配进程异常栈；</li>
<li>为子进程注册进程异常处理函数；（因为子进程运行的时候大部分的页属性是COW，也就是不可能自己通过系统调用注册进程异常处理函数）；</li>
<li>修改子进程运行状态-》可运行状态。</li>
</ol>
<h3 id="preemptive-multitasking-and-inter-process-communication-ipc">Preemptive Multitasking and Inter-Process communication (IPC)</h3>
<p>实现时钟中断，利用时钟中断完成任务的抢占；</p>
<p>实现ipc，其ipc有如下机制：</p>
<ol>
<li>ipc是基于系统调用实现的，可以传递一个整数或者传递一个虚拟地址（对应着一个物理页）；</li>
<li>ipc的发送方处于polling状态；</li>
<li>ipc的接收方处于进程不可运行态，由ipc的发送方不断的尝试发送数据，发送成功后由发送方修改接收方的进程运行状态；</li>
</ol>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Lab3 - 实验笔记</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/course/mit6828/lab3/" />
            <id>https://chengshuyi.github.io/posts/course/mit6828/lab3/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-25T13:34:13+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[lab3的实验主要涉及到x86的硬件机制：中断、异常等等。因此，需要自己实现中断向量表、保存和恢复上下文、系统调用和页异常相关的函数。 lab3也新增了用户进程的概念，需……]]></summary>
            
                <content type="html"><![CDATA[<p>lab3的实验主要涉及到x86的硬件机制：中断、异常等等。因此，需要自己实现中断向量表、保存和恢复上下文、系统调用和页异常相关的函数。</p>
<p>lab3也新增了用户进程的概念，需要实现相关函数。</p>
<h3 id="user-environments">user environments</h3>
<p>jos的user environments是tcb的概念，用于描述一个进程实体。其结构如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">Env</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Trapframe</span> <span class="n">env_tf</span><span class="p">;</span>	<span class="c1">// Saved registers
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env_link</span><span class="p">;</span>		<span class="c1">// Next free Env
</span><span class="c1"></span>	<span class="n">envid_t</span> <span class="n">env_id</span><span class="p">;</span>				<span class="c1">// Unique environment identifier
</span><span class="c1"></span>	<span class="n">envid_t</span> <span class="n">env_parent_id</span><span class="p">;</span>		<span class="c1">// env_id of this env&#39;s parent
</span><span class="c1"></span>	<span class="k">enum</span> <span class="n">EnvType</span> <span class="n">env_type</span><span class="p">;</span>		<span class="c1">// Indicates special system environments
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="n">env_status</span><span class="p">;</span>		<span class="c1">// Status of the environment
</span><span class="c1"></span>	<span class="n">uint32_t</span> <span class="n">env_runs</span><span class="p">;</span>			<span class="c1">// Number of times environment has run
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">env_cpunum</span><span class="p">;</span>				<span class="c1">// The CPU that the env is running on
</span><span class="c1"></span>
	<span class="c1">// Address space
</span><span class="c1"></span>	<span class="n">pde_t</span> <span class="o">*</span><span class="n">env_pgdir</span><span class="p">;</span>			<span class="c1">// Kernel virtual address of page dir
</span><span class="c1"></span>
	<span class="c1">// Exception handling
</span><span class="c1"></span>	<span class="kt">void</span> <span class="o">*</span><span class="n">env_pgfault_upcall</span><span class="p">;</span>	<span class="c1">// Page fault upcall entry point
</span><span class="c1"></span>
	<span class="c1">// Lab 4 IPC
</span><span class="c1"></span>	<span class="kt">bool</span> <span class="n">env_ipc_recving</span><span class="p">;</span>		<span class="c1">// Env is blocked receiving
</span><span class="c1"></span>	<span class="kt">void</span> <span class="o">*</span><span class="n">env_ipc_dstva</span><span class="p">;</span>		<span class="c1">// VA at which to map received page
</span><span class="c1"></span>	<span class="n">uint32_t</span> <span class="n">env_ipc_value</span><span class="p">;</span>		<span class="c1">// Data value sent to us
</span><span class="c1"></span>	<span class="n">envid_t</span> <span class="n">env_ipc_from</span><span class="p">;</span>		<span class="c1">// envid of the sender
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">env_ipc_perm</span><span class="p">;</span>			<span class="c1">// Perm of page mapping received
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="中断和异常">中断和异常</h3>
<p>中断描述符表：x86最多有256个表项；</p>
<p>TSS：包含了段选择子和栈的基址；</p>
<p>0-31号中断：同步异常；</p>
<p>31号以上中断：软中断和硬中断；</p>
<p>嵌套中断和异常：</p>
<blockquote>
<p><strong>Exercise 1.</strong> Modify <code>mem_init()</code> in <code>kern/pmap.c</code> to allocate and map the <code>envs</code> array. This array consists of exactly <code>NENV</code> instances of the <code>Env</code> structure allocated much like how you allocated the <code>pages</code> array. Also like the <code>pages</code> array, the memory backing <code>envs</code> should also be mapped user read-only at <code>UENVS</code> (defined in <code>inc/memlayout.h</code>) so user processes can read from this array.</p>
</blockquote>
<p>为<code>NENV</code>个<code>struct Env</code>分配内存空间，然后将其映射到位于用户地址空间的虚拟地址UENVS。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//分配内存
</span><span class="c1"></span><span class="n">envs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="o">*</span><span class="p">)</span><span class="n">boot_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span><span class="o">*</span><span class="n">NENV</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">envs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span><span class="o">*</span><span class="n">NENV</span><span class="p">);</span>
<span class="c1">//做映射
</span><span class="c1"></span><span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span><span class="n">UENVS</span><span class="p">,</span><span class="n">ROUNDUP</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span><span class="o">*</span><span class="n">NENV</span><span class="p">,</span><span class="n">PGSIZE</span><span class="p">),</span><span class="n">PADDR</span><span class="p">(</span><span class="n">envs</span><span class="p">),</span><span class="n">PTE_P</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>Exercise 2.</strong> In the file <code>env.c</code>, finish coding the following functions:</p>
<ul>
<li><code>env_init()</code></li>
</ul>
<p>Initialize all of the <code>Env</code> structures in the <code>envs</code> array and add them to the <code>env_free_list</code>. Also calls <code>env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).</p>
<ul>
<li><code>env_setup_vm()</code></li>
</ul>
<p>Allocate a page directory for a new environment and initialize the kernel portion of the new environment's address space.</p>
<ul>
<li><code>region_alloc()</code></li>
</ul>
<p>Allocates and maps physical memory for an environment</p>
<ul>
<li><code>load_icode()</code></li>
</ul>
<p>You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.</p>
<ul>
<li><code>env_create()</code></li>
</ul>
<p>Allocate an environment with <code>env_alloc</code> and call <code>load_icode</code> to load an ELF binary into it.</p>
<ul>
<li><code>env_run()</code></li>
</ul>
<p>Start a given environment running in user mode.</p>
</blockquote>
<p>函数较多，实现简单，这里不再贴代码。</p>
<ul>
<li>
<p><code>env_init</code>函数的实现类似于<code>page_init</code>函数，主要将空闲的<code>struct Env</code>插入到<code>env_free_list</code>链表上；</p>
</li>
<li>
<p><code>env_setup_vm</code>函数为该进程分配一个页目录表，并将内核页目录表内容拷贝到该进程的页目录表；</p>
</li>
<li>
<p><code>region_alloc</code>函数为进程分配内存，并将其映射到其地址空间，其参数是<code>va</code>和<code>len</code>；</p>
</li>
<li>
<p><code>load_icode</code>函数解析elf文件头部信息，将其加载到指定的地址上；修改进程的eip值；为该进程创建用户栈；</p>
</li>
<li>
<p><code>env_alloc</code>函数工作流程：调用<code>env_setup_vm</code>完成进程的页目录表的分配；分配一个id；设置该进程的寄存器的值，包括：ds、es、ss、esp、cs等；</p>
</li>
<li>
<p><code>env_create</code>函数先后调用了<code>env_alloc</code>函数和<code>load_icode</code>函数；</p>
</li>
<li>
<p><code>env_run</code>函数根据进程是否发生切换来决定是否更新cr3寄存器的值；</p>
</li>
</ul>
<blockquote>
<p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you'll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S; the </code>SETGATE` macro will be helpful here.</p>
</blockquote>
<p>具体代码没有粘贴，记录一下具体的中断流程：</p>
<ol>
<li>中断或者异常发生，cpu判断当前特权级来决定是否切换到内核栈；</li>
<li>如下图所示，如果发生特权级切换需要特别保存ss和esp寄存器（中断嵌套的话只能发生在内核态）；</li>
<li>保存剩余的寄存器到内核栈中（具体可以查看int指令执行的具体内容）；</li>
<li>根据中段号跳转到IDT的相应entry；</li>
<li>压入中断号；</li>
<li>保存用户上下文；</li>
<li>中断处理函数；</li>
<li>恢复用户上下文；</li>
<li>执行iret指令，从内核栈中pop出ss和esp寄存器；</li>
</ol>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200425200239.png" alt=""></p>
<h3 id="页异常">页异常</h3>
<p>页异常的中断向量号是14，当页异常发生时，处理器会自动保存其虚拟地址到<code>cr2</code>寄存器；</p>
<blockquote>
<p><strong>Exercise 5.</strong> Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">		<span class="k">case</span> <span class="nl">T_PGFLT</span><span class="p">:{</span>
			<span class="n">page_fault_handler</span><span class="p">(</span><span class="n">tf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="断点异常">断点异常</h3>
<p>断点异常的中断向量号是3，调试程序时需要在相应的指令下插入该条指令（int 0x3），触发软件异常，可以调试程序。</p>
<blockquote>
<p><strong>Exercise 6.</strong> Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">		<span class="k">case</span> <span class="nl">T_BRKPT</span><span class="p">:{</span>
			<span class="n">monitor</span><span class="p">(</span><span class="n">tf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="系统调用">系统调用</h3>
<blockquote>
<p><strong>Exercise 7.</strong> Add a handler in the kernel for interrupt vector <code>T_SYSCALL</code>. You will have to edit <code>kern/trapentry.S</code> and <code>kern/trap.c</code>'s <code>trap_init()</code>. You also need to change <code>trap_dispatch()</code> to handle the system call interrupt by calling <code>syscall()</code> (defined in <code>kern/syscall.c</code>) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in <code>%eax</code>. Finally, you need to implement <code>syscall()</code> in <code>kern/syscall.c</code>. Make sure <code>syscall()</code> returns <code>-E_INVAL</code> if the system call number is invalid. You should read and understand <code>lib/syscall.c</code> (especially the inline assembly routine) in order to confirm your understanding of the system call interface. Handle all the system calls listed in <code>inc/syscall.h</code> by invoking the corresponding kernel function for each call.</p>
</blockquote>
<p>实现系统调用部分，为用户程序提供内核服务，具体看代码:-）。</p>
<h4 id="用户程序入口">用户程序入口</h4>
<p>主要关注几个文件的代码，分别是<code>lib/entry.S</code>、<code>lib/libmain.c</code>和<code>lib/exit.c</code>。</p>
<blockquote>
<p><strong>Exercise 8.</strong> Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print &quot;<code>hello, world</code>&quot; and then print &quot;<code>i am environment 00001000</code>&quot;. <code>user/hello</code> then attempts to &quot;exit&quot; by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>).</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">libmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// set thisenv to point at our Env structure in envs[].
</span><span class="c1"></span>	<span class="c1">// LAB 3: Your code here.
</span><span class="c1"></span>	<span class="n">envid_t</span> <span class="n">id</span> <span class="o">=</span> <span class="n">sys_getenvid</span><span class="p">();</span>
	<span class="n">thisenv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">envs</span><span class="p">[</span><span class="n">ENVX</span><span class="p">(</span><span class="n">id</span><span class="p">)];</span>

	<span class="c1">// save the name of the program so that panic() can use it
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">binaryname</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="c1">// call user main routine
</span><span class="c1"></span>	<span class="n">umain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="c1">// exit gracefully
</span><span class="c1"></span>	<span class="n">exit</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="内存保护机制">内存保护机制</h4>
<ol>
<li>用户进程传进来的指针一定要检查，首先检查该指针不能在内核地址空间，然后判断是否存在该虚拟地址，最后检查读写权限；</li>
<li>内核不能够发生页错误；</li>
</ol>
<blockquote>
<p><strong>Exercise 9.</strong> Change <code>kern/trap.c</code> to panic if a page fault happens in kernel mode.</p>
<p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p>
<p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p>
</blockquote>
<p>内核不能够发生页错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	<span class="k">if</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">tf_cs</span> <span class="o">==</span> <span class="n">GD_KT</span><span class="p">){</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&#34;kernel page fault</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>用户进程传进来的指针检查函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">user_mem_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// LAB 3: Your code here.
</span><span class="c1"></span>	<span class="n">uintptr_t</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ROUNDDOWN</span><span class="p">((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">va</span><span class="p">,</span><span class="n">PGSIZE</span><span class="p">);</span>
	<span class="n">uintptr_t</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">va</span><span class="o">+</span><span class="n">len</span><span class="p">,</span><span class="n">PGSIZE</span><span class="p">);</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte_entry</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(;</span><span class="n">s</span><span class="o">&lt;</span><span class="n">e</span><span class="p">;</span><span class="n">s</span><span class="o">+=</span><span class="n">PGSIZE</span><span class="p">){</span>
		<span class="c1">// cprintf(&#34;va is %x ULIM is %x\n&#34;,s,ULIM);
</span><span class="c1"></span>		<span class="n">page_lookup</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pte_entry</span><span class="p">);</span> 
        <span class="c1">// 1. 首先检查该指针不能在内核地址空间
</span><span class="c1"></span>        <span class="c1">// 2. 然后判断是否存在该虚拟地址
</span><span class="c1"></span>        <span class="c1">// 3. 最后检查读写权限
</span><span class="c1"></span>		<span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">&gt;</span><span class="n">ULIM</span> <span class="o">||</span> <span class="n">pte_entry</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="p">(</span><span class="n">PGOFF</span><span class="p">(</span><span class="o">*</span><span class="n">pte_entry</span><span class="p">)</span><span class="o">&amp;</span><span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">perm</span><span class="p">){</span>
			<span class="n">user_mem_check_addr</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">s</span><span class="p">,(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">va</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E_FAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Lab2 - 实验笔记</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/course/mit6828/lab2/" />
            <id>https://chengshuyi.github.io/posts/course/mit6828/lab2/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-25T13:34:11+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[lab2实验代码 lab2的实验主要涉及到物理内存和虚拟内存的管理，其中JOS内核按页对物理内存进行管理，所以其分配、释放的最小内存大小是一个物理页。相应的需要实现三个物……]]></summary>
            
                <content type="html"><![CDATA[<p><a href="https://github.com/chengshuyi/jos-lab/commit/ca384c1373d3a34cfa82435fdd366965a3b4c071">lab2实验代码</a></p>
<p>lab2的实验主要涉及到物理内存和虚拟内存的管理，其中JOS内核按页对物理内存进行管理，所以其分配、释放的最小内存大小是一个物理页。相应的需要实现三个物理页相关函数：</p>
<ul>
<li><code>void page_init(void)</code></li>
<li><code>struct PageInfo *page_alloc(int alloc_flags)</code></li>
<li><code>void page_free(struct PageInfo *pp)</code></li>
</ul>
<p>JOS内核的虚拟地址空间大小是256MB，x86中包含分段机制和分页机制，JOS分段机制比较固定，占用整个地址空间大小。因此，整个实验比较关注于基于mmu的分页管理机制。针对分页机制需要实现四个函数：</p>
<ul>
<li><code>pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)</code></li>
<li><code>void page_remove(pde_t *pgdir, void *va)</code></li>
<li><code>struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)</code></li>
<li><code>int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)</code></li>
</ul>
<p>本文不会涉及到具体代码，简单记录了比较关键的部分。</p>
<h3 id="物理页管理">物理页管理</h3>
<p>JOS的物理内存粒度是页，所有的空闲页通过链表进行管理，下面是内核物理内存管理的流程，特别需要注意到在没有初始化内存之前，内核如何为数据结构分配内存。</p>
<ol>
<li>
<p>通过I/O端口获取物理内存的分布情况，分为两部分，base memory占用640KB，extended memory占用130432KB。可以知道base memory指的是<a href="">lab1</a>讲的low memory；</p>
<blockquote>
<p>Physical memory: 131072K available, base = 640K, extended = 130432K</p>
</blockquote>
</li>
<li>
<p>实现<code>boot_alloc</code>函数，该函数主要完成在没有建立页管理机制之前的内存分配工作。其工作流程是：</p>
<p>a. 根据链接脚本的end参数获取内核代码所占内存的终止地址，并将其按页对齐；</p>
<p>b. 为调用者分配内存，更新终止位置；</p>
</li>
<li>
<p>调用<code>boot_alloc</code>函数为内核页目录表<code>kern_pgdir</code>分配内存，大小是PGSIZE，二级页表在做映射的时候才进行分配；</p>
</li>
<li>
<p>建立自映射，这个在lab4还会遇到；</p>
</li>
<li>
<p>调用<code>boot_alloc</code>函数为管理页数据结构<code>struct PageInfo</code>分配内存，其内存大小是<code>sizeof(struct PageInfo)*npages</code>；</p>
</li>
<li>
<p><code>page_init</code>函数初始化<code>struct PageInfo</code>，主要是将空闲页挂在空闲页链表<code>page_free_list</code>上，此时空闲页主要有两部分构成：1. low memory部分； 2. extended memory剩余部分；</p>
</li>
<li>
<p><code>page_init</code>函数从空闲页链表上取出一页；</p>
</li>
<li>
<p><code>page_free</code>函数将该页挂在空闲链表上；</p>
</li>
</ol>
<h3 id="虚拟内存">虚拟内存</h3>
<p>在x86架构中，有三种地址术语，分别是：虚拟地址、线性地址和物理地址。虚拟地址通过分段机制转换得到线性地址，线性地址通过分页机制转换可以得到物理地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">
           <span class="n">Selector</span>  <span class="o">+--------------+</span>         <span class="o">+-----------+</span>
          <span class="o">----------&gt;|</span>              <span class="o">|</span>         <span class="o">|</span>           <span class="o">|</span>
                     <span class="o">|</span> <span class="n">Segmentation</span> <span class="o">|</span>         <span class="o">|</span>  <span class="n">Paging</span>   <span class="o">|</span>
<span class="n">Software</span>             <span class="o">|</span>              <span class="o">|--------&gt;|</span>           <span class="o">|----------&gt;</span>  <span class="n">RAM</span>
            <span class="n">Offset</span>   <span class="o">|</span>  <span class="n">Mechanism</span>   <span class="o">|</span>         <span class="o">|</span> <span class="n">Mechanism</span> <span class="o">|</span>
          <span class="o">----------&gt;|</span>              <span class="o">|</span>         <span class="o">|</span>           <span class="o">|</span>
                     <span class="o">+--------------+</span>         <span class="o">+-----------+</span>
            <span class="n">Virtual</span>                   <span class="n">Linear</span>                <span class="n">Physical</span>
</code></pre></td></tr></table>
</div>
</div><p>关于分段机制，现在操作系统用的很少，大部分将段基地址设置成<code>0</code>，段的大小是<code>0xffffffff</code>，所以虚拟地址等于线性地址。</p>
<blockquote>
<p>分段机制目前用的比较多的是它的特权等级，jos中分为内核段和用户段；</p>
</blockquote>
<p>在lab1中只映射了4MB的物理内存，在qemu中运行<code>info pg</code>可以得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">VPN</span> <span class="n">range</span>     <span class="n">Entry</span>         <span class="n">Flags</span>        <span class="n">Physical</span> <span class="n">page</span>
<span class="p">[</span><span class="mo">00000</span><span class="o">-</span><span class="mf">003ff</span><span class="p">]</span>  <span class="n">PDE</span><span class="p">[</span><span class="mo">000</span><span class="p">]</span>     <span class="o">----</span><span class="n">A</span><span class="o">----</span><span class="n">P</span>
  <span class="p">[</span><span class="mo">00000</span><span class="o">-</span><span class="mo">000</span><span class="n">b7</span><span class="p">]</span>  <span class="n">PTE</span><span class="p">[</span><span class="mo">000</span><span class="o">-</span><span class="mi">0</span><span class="n">b7</span><span class="p">]</span> <span class="o">--------</span><span class="n">WP</span> <span class="mo">00000</span><span class="o">-</span><span class="mo">000</span><span class="n">b7</span>
  <span class="p">...</span>
  <span class="p">[</span><span class="mo">00114</span><span class="o">-</span><span class="mf">003ff</span><span class="p">]</span>  <span class="n">PTE</span><span class="p">[</span><span class="mi">114</span><span class="o">-</span><span class="mf">3ff</span><span class="p">]</span> <span class="o">--------</span><span class="n">WP</span> <span class="mo">00114</span><span class="o">-</span><span class="mf">003ff</span>
<span class="p">[</span><span class="n">f0000</span><span class="o">-</span><span class="n">f03ff</span><span class="p">]</span>  <span class="n">PDE</span><span class="p">[</span><span class="mi">3</span><span class="n">c0</span><span class="p">]</span>     <span class="o">----</span><span class="n">A</span><span class="o">---</span><span class="n">WP</span>
  <span class="p">[</span><span class="n">f0000</span><span class="o">-</span><span class="n">f00b7</span><span class="p">]</span>  <span class="n">PTE</span><span class="p">[</span><span class="mo">000</span><span class="o">-</span><span class="mi">0</span><span class="n">b7</span><span class="p">]</span> <span class="o">--------</span><span class="n">WP</span> <span class="mo">00000</span><span class="o">-</span><span class="mo">000</span><span class="n">b7</span>
  <span class="p">...</span>
  <span class="p">[</span><span class="n">f0114</span><span class="o">-</span><span class="n">f03ff</span><span class="p">]</span>  <span class="n">PTE</span><span class="p">[</span><span class="mi">114</span><span class="o">-</span><span class="mf">3ff</span><span class="p">]</span> <span class="o">--------</span><span class="n">WP</span> <span class="mo">00114</span><span class="o">-</span><span class="mf">003ff</span>
</code></pre></td></tr></table>
</div>
</div><p>从上面可以看到，物理内存[0,4MB)分别映射到虚拟内存[0,4MB)和[0xf0000000,0xf03ff000)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * Virtual memory map:                                Permissions
</span><span class="cm"> *                                                    kernel/user
</span><span class="cm"> *
</span><span class="cm"> *    4 Gig --------&gt;  +------------------------------+
</span><span class="cm"> *                     |                              | RW/--
</span><span class="cm"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="cm"> *                     :              .               :
</span><span class="cm"> *                     :              .               :
</span><span class="cm"> *                     :              .               :
</span><span class="cm"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
</span><span class="cm"> *                     |                              | RW/--
</span><span class="cm"> *                     |   Remapped Physical Memory   | RW/--
</span><span class="cm"> *                     |                              | RW/--
</span><span class="cm"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+
</span><span class="cm"> *    KSTACKTOP        |     CPU0&#39;s Kernel Stack      | RW/--  KSTKSIZE   |
</span><span class="cm"> *                     | - - - - - - - - - - - - - - -|                   |
</span><span class="cm"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
</span><span class="cm"> *                     +------------------------------+                   |
</span><span class="cm"> *                     |     CPU1&#39;s Kernel Stack      | RW/--  KSTKSIZE   |
</span><span class="cm"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE
</span><span class="cm"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
</span><span class="cm"> *                     +------------------------------+                   |
</span><span class="cm"> *                     :              .               :                   |
</span><span class="cm"> *                     :              .               :                   |
</span><span class="cm"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+
</span><span class="cm"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE
</span><span class="cm"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000
</span><span class="cm"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
</span><span class="cm"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000
</span><span class="cm"> *                     |          RO PAGES            | R-/R-  PTSIZE
</span><span class="cm"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000
</span><span class="cm"> *                     |           RO ENVS            | R-/R-  PTSIZE
</span><span class="cm"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000
</span><span class="cm"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
</span><span class="cm"> *                     +------------------------------+ 0xeebff000
</span><span class="cm"> *                     |       Empty Memory (*)       | --/--  PGSIZE
</span><span class="cm"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000
</span><span class="cm"> *                     |      Normal User Stack       | RW/RW  PGSIZE
</span><span class="cm"> *                     +------------------------------+ 0xeebfd000
</span><span class="cm"> *                     |                              |
</span><span class="cm"> *                     |                              |
</span><span class="cm"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="cm"> *                     .                              .
</span><span class="cm"> *                     .                              .
</span><span class="cm"> *                     .                              .
</span><span class="cm"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
</span><span class="cm"> *                     |     Program Data &amp; Heap      |
</span><span class="cm"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000
</span><span class="cm"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE
</span><span class="cm"> *                     |                              |
</span><span class="cm"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+
</span><span class="cm"> *                     |       Empty Memory (*)       |                   |
</span><span class="cm"> *                     | - - - - - - - - - - - - - - -|                   |
</span><span class="cm"> *                     |  User STAB Data (optional)   |                 PTSIZE
</span><span class="cm"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |
</span><span class="cm"> *                     |       Empty Memory (*)       |                   |
</span><span class="cm"> *    0 ------------&gt;  +------------------------------+                 --+
</span></code></pre></td></tr></table>
</div>
</div><p>上面是虚拟内存地址空间分布的情况，下面是建立映射的大致过程：</p>
<ol>
<li>前面已经为页目录表<code>kern_pgdir</code>分配了内存，所以接下来的建立地址映射的过程就是在<code>kern_pgdir</code>插入页表项，以及分配页表；</li>
<li>将前面分配的<code>sizeof(struct PageInfo) * npage</code>映射到UPAGES；</li>
<li>将内核栈映射到KSTACKTOP；</li>
<li>将整个物理内存映射内核虚拟地址空间；</li>
<li>将<code>kern_pgdir</code>加载到cr3寄存器；</li>
</ol>
<p>下面是几个函数的实现功能，描述的比较简单，但实际上有很多的细节需要去考虑：</p>
<ol>
<li>
<p><code>pgdir_walk</code>函数查找虚拟地址所对应的页表项，返回该页表项的指针，也就是<code>&amp;kern_pgdir[PDX(va)][PTX(va)]</code>；</p>
</li>
<li>
<p><code>page_lookup</code>函数查找虚拟地址对应的物理页，也就是<code>pa2page(kern_pgdir[PDX(va)][PTX(va)])</code>；</p>
</li>
<li>
<p><code>page_remove</code>函数完成两个功能：</p>
<p>a. 取消虚拟地址映射；</p>
<p>b. 回收物理页。</p>
<p>c. 取消映射原理是<code>kern_pgdir[PDX(va)][PTX(va)] = 0</code>，回收物理页原理将该页插入到空闲页链表即可。</p>
</li>
<li>
<p><code>page_insert</code>函数对该页建立映射，也就是<code>kern_pgdir[PDX(va)][PTX(va)]=PGNUM(va)</code>；</p>
</li>
</ol>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Lab1 - 实验笔记</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/course/mit6828/lab1/" />
            <id>https://chengshuyi.github.io/posts/course/mit6828/lab1/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-24T20:24:40+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[lab1的实验代码 lab1的实验主要讲述了x86的物理地址空间的分布，特别需要注意的是BIOS ROM，pc启动后运行的第一条指令就在BIOS ROM中。接着便是BIOS如……]]></summary>
            
                <content type="html"><![CDATA[<p><a href="https://github.com/chengshuyi/jos-lab/commit/487630546efdc7ecc668ced4508cf6f164c56fd6">lab1的实验代码</a></p>
<p>lab1的实验主要讲述了x86的物理地址空间的分布，特别需要注意的是BIOS ROM，pc启动后运行的第一条指令就在BIOS ROM中。接着便是BIOS如何从硬盘中加载bootloader，最后是bootloader如何从硬盘中加载内核。</p>
<p>在bootloader代码中有几个比较难懂的点，一个是使能A20，另外一个是保护模式和实模式。使能A20是为了兼容传统的16位PC的解决方案。保护模式和实模式涉及到CS:IP的计算方式。</p>
<p>本文不会涉及到具体代码，简单记录了比较关键的部分。特别是较清晰的梳理了BIOS、bootloader和内核之间的关系，以及其各自对应的启动流程。</p>
<h3 id="the-pcs-physical-address-space">The PC's Physical Address Space</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0xFFFFFFFF</span> <span class="p">(</span><span class="mi">4</span><span class="n">GB</span><span class="p">)</span>
<span class="o">|</span>      <span class="mi">32</span><span class="o">-</span><span class="n">bit</span>      <span class="o">|</span>
<span class="o">|</span>  <span class="n">memory</span> <span class="n">mapped</span>   <span class="o">|</span>
<span class="o">|</span>     <span class="n">devices</span>      <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span>\

<span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span><span class="err">\</span><span class="o">/</span>\
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>      <span class="n">Unused</span>      <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">amount</span> <span class="n">of</span> <span class="n">RAM</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span> <span class="n">Extended</span> <span class="n">Memory</span>  <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x00100000</span> <span class="p">(</span><span class="mi">1</span><span class="n">MB</span><span class="p">)</span>
<span class="o">|</span>     <span class="n">BIOS</span> <span class="n">ROM</span>     <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x000F0000</span> <span class="p">(</span><span class="mi">960</span><span class="n">KB</span><span class="p">)</span>
<span class="o">|</span>  <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">devices</span><span class="p">,</span> <span class="o">|</span>
<span class="o">|</span>  <span class="n">expansion</span> <span class="n">ROMs</span>  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x000C0000</span> <span class="p">(</span><span class="mi">768</span><span class="n">KB</span><span class="p">)</span>
<span class="o">|</span>   <span class="n">VGA</span> <span class="n">Display</span>    <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x000A0000</span> <span class="p">(</span><span class="mi">640</span><span class="n">KB</span><span class="p">)</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">|</span>    <span class="n">Low</span> <span class="n">Memory</span>    <span class="o">|</span>
<span class="o">|</span>                  <span class="o">|</span>
<span class="o">+------------------+</span>  <span class="o">&lt;-</span> <span class="mh">0x00000000</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>low Memory对应的是早期的处理器，只能够访问640KB内存空间；</li>
<li>然而16位的8088处理器能够访问1MB的地址空间，可以知道对应地址总线是20位，但是由于数据总线是16位，对应的寄存器也就是16位的，所以intel采用segment:offset来计算物理地址<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>；</li>
<li>VGA(video display buffers)：视频显示用的，每隔一定的时间，对应的硬件就会从该区域读取要显示的图像。</li>
<li>ROMs：存放固件，非易失存储器。</li>
<li>BIOS ROM：一般是nor flash，nor flash支持XIP(eXecute In Place)，所以可以在这里存放bios代码。</li>
<li>Extended Memory：高于1MB的剩余物理空间，最多到4GB。</li>
</ul>
<blockquote>
<p>JOS只能使用前256MB的物理内存？</p>
<p>JOS内核的虚拟地址空间是[0xf0000000,0xffffffff]，大小是256MB。所以内核在没有高端内存的概念下，只能管理256MB物理内存。</p>
</blockquote>
<h3 id="bios和bootloader">bios和bootloader</h3>
<p>bios的主要工作内容是：系统初始化和自检、加载bootloader到内存中以及将控制权交给bootloader。下面是bios-&gt;bootloader-&gt;kernel entry的大致流程：</p>
<ol>
<li>
<p>处理器启动时进入real模式，并设置<code>cs=0xf000</code>和<code>ip=0xfff0</code>。物理地址是：<code>physical address = 16 * segment + offset</code>，所以第一条指令的地址是<code>0xffff0</code>，位于BIOS ROM空间；</p>
</li>
<li>
<p>ROM BIOS开机自检，其第一个指令是<code>[f000:fff0] 0xffff0:	ljmp   $0xf000,$0xe05b</code>；</p>
</li>
<li>
<p>ROM BIOS完成初始化后，会将我们的启动代码（bootloader）从硬盘第一个扇区（512字节）加载到物理地址<code>0000:7c00</code>，最后<code>jmp</code>指令跳转到我们的代码处执行，也就是物理地址<code>0000:7c00</code>；</p>
</li>
<li></li>
<li>
<p>Enable A20<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>：80286（24根地址线）为了兼容8088（20根地址线）；</p>
<blockquote>
<p>8086所能访问的物理地址空间：0(0x0000:0x0000)到0x10FFEF(FFFF:FFFF)，多出来了第20位，因为8086地址线只有20根，所以没有影响；</p>
<p>但是在80286中，Intel把地址线扩展成24根了，FFFF:FFFF真的就是0x10FFEF了，你让那些legacy software怎么活？！本来人家想读0xFFEF的，怎么成了0x10FFEF？不是人家不想好好工作，是你硬件设计的不让人家好好工作嘛。</p>
<p>乃们看出来了没？A20 是 80286 时代照顾8088软件的产物。通常所说的32位保护模式是 80386 才出现的，**所以，A20跟保护模式毛关系都没有！**开不开都一样进，影响的只是第20位而已</p>
</blockquote>
</li>
<li>
<p>切换模式：从实模式切换到保护模式，保护模式使用gdt和ldt（段寄存器和偏移从16位到32位），可以访问到比实模式更多的物理地址空间；</p>
</li>
<li>
<p>根据elf的信息将内核代码从硬盘加载到物理内存中；</p>
<p>IO端口地址<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">Address</span>	<span class="n">USE</span>
<span class="mo">0010</span><span class="o">-</span><span class="mf">001F</span>	<span class="n">System</span>
<span class="mf">01F</span><span class="mi">0</span><span class="o">-</span><span class="mf">01F</span><span class="mi">7</span>	<span class="n">IDE</span> <span class="n">interface</span> <span class="o">-</span> <span class="n">Primary</span> <span class="n">channel</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p><strong>习题：</strong></p>
<ul>
<li>
<p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp"># 前面使用lgdt指令将gdt加载到对应的寄存器
</span><span class="cp"></span><span class="n">orl</span>     <span class="err">$</span><span class="n">CR0_PE_ON</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
<span class="n">movl</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr0</span>
<span class="n">ljmp</span>    <span class="err">$</span><span class="n">PROT_MODE_CSEG</span><span class="p">,</span> <span class="err">$</span><span class="n">protcseg</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码使能保护模式，将cr0寄存器的第一位置1；第三行代码实在32bit模式下运行的。</p>
</li>
<li>
<p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p>
<p><code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code></p>
<p>运行<code>readelf -h obj/kern/kernel</code>可以知道kernel的entry是0x1000c，所以第一条指令是：<code>f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472</code>。</p>
<blockquote>
<p>这里的0xf010000c是虚拟地址（线性地址），0x1000c是物理地址；bootloader将内核加载到线性地址，这时还没有开启mmu，所以在开启mmu之前的代码必须是位置无关代码；如果要访问位置相关的代码，需要使用RELOC计算出线性地址对应的物理地址；</p>
<pre><code>kernel.ld
/* Link the kernel at this address: &quot;.&quot; means the current address */
. = 0xF0100000;

/* AT(...) gives the load address of this section, which tells
   the boot loader where to load the kernel in physical memory */
.text : AT(0x100000) {
    *(.text .stub .text.* .gnu.linkonce.t.*)
}
</code></pre>
</blockquote>
</li>
<li>
<p><em>Where</em> is the first instruction of the kernel?</p>
<p><code>0x1000c</code></p>
</li>
<li>
<p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p>
<p>kernel最终被编译成elf文件，elf头部信息包含代码的详细信息。</p>
</li>
</ul>
<h3 id="内核启动流程">内核启动流程</h3>
<p>下面是内核汇编代码的大致运行流程：</p>
<ol>
<li>
<p>此时分页系统还未开启，内核访问位置相关的代码（比如数据），需要使用RELOC，手动将虚拟地址转换成物理地址（取数据时需要转换）；</p>
</li>
<li>
<p>将页目录表基地址加载到cr3寄存器，再修改cr0寄存器，开启分页系统；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pde_t</span> <span class="n">entry_pgdir</span><span class="p">[</span><span class="n">NPDENTRIES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="c1">// Map VA&#39;s [0, 4MB) to PA&#39;s [0, 4MB)
</span><span class="c1"></span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
     <span class="o">=</span> <span class="p">((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">entry_pgtable</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">)</span> <span class="o">+</span> <span class="n">PTE_P</span><span class="p">,</span>
 <span class="c1">// Map VA&#39;s [KERNBASE, KERNBASE+4MB) to PA&#39;s [0, 4MB)
</span><span class="c1"></span> <span class="p">[</span><span class="n">KERNBASE</span><span class="o">&gt;&gt;</span><span class="n">PDXSHIFT</span><span class="p">]</span>
     <span class="o">=</span> <span class="p">((</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">entry_pgtable</span> <span class="o">-</span> <span class="n">KERNBASE</span><span class="p">)</span> <span class="o">+</span> <span class="n">PTE_P</span> <span class="o">+</span> <span class="n">PTE_W</span>
<span class="p">};</span>
<span class="err">可以看到这里映射了两段虚拟地址，分别是</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="n">MB</span><span class="p">)</span> <span class="err">和</span> <span class="p">[</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="n">KERNBASE</span><span class="o">+</span><span class="mi">4</span><span class="n">MB</span><span class="p">)</span><span class="err">。讲一下为什么要映射</span><span class="n">VA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="n">MB</span><span class="p">)</span><span class="err">？因为当前的</span><span class="n">ip处于</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="n">MB</span><span class="p">)</span><span class="err">，所以开启分页系统之后</span><span class="n">ip仍然处于</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="n">MB</span><span class="p">)</span><span class="err">，如果没有</span><span class="n">VA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="n">MB</span><span class="p">)</span><span class="err">的映射会出现</span><span class="n">page</span> <span class="n">fault</span><span class="err">。</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>修改ip的值到内核空间；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"> <span class="n">mov</span>	<span class="err">$</span><span class="n">relocated</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
 <span class="n">jmp</span>	<span class="o">*%</span><span class="n">eax</span>
<span class="nl">relocated</span><span class="p">:</span>
 <span class="p">...</span>
<span class="err">编译的时候都是按虚拟地址来进行编译的，所以</span><span class="n">relocated保存的是虚拟地址</span><span class="err">。</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>进入c语言代码；</p>
</li>
</ol>
<p><strong>习题：</strong></p>
<ul>
<li>
<p>Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</p>
<p>printf库解析传进来的参数转换成字符串，并一个个的传给console；</p>
<p>console将字符串打印出来，包括串口和显示屏显示；</p>
</li>
<li>
<p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC's calling convention on the x86.</p>
<p>Trace the execution of the following code step-by-step:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">cprintf</span><span class="p">(</span><span class="s">&#34;x %d, y %x, z %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</li>
<li>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li>
</ul>
<blockquote>
<p>我们知道再x86中参数都通过栈传递（现在一部分是通过通用寄存器传递的），而参数压栈的顺序是从右到左，所以fmt是指向上一个函数的栈顶，也就是<code>0x8(%ebp)</code>。ap指向fmt的前一个参数，也就是lea    0xc(%ebp),%eax。具体看下面的代码：</p>
</blockquote>
<pre><code class="language-assembly" data-lang="assembly">int
cprintf(const char *fmt, ...)
{
f0100ad1:	55                   	push   %ebp
f0100ad2:	89 e5                	mov    %esp,%ebp
f0100ad4:	83 ec 10             	sub    $0x10,%esp
  va_list ap;
  int cnt;
  
  va_start(ap, fmt);
f0100ad7:	8d 45 0c             	lea    0xc(%ebp),%eax   // 取参数（除了fmt参数）的首地址
  cnt = vcprintf(fmt, ap);
f0100ada:	50                   	push   %eax
f0100adb:	ff 75 08             	pushl  0x8(%ebp)		// 取值，该值指向fmt的字符串首地址
f0100ade:	e8 b7 ff ff ff       	call   f0100a9a &lt;vcprintf&gt;
  va_end(ap);
  
  return cnt;
}
</code></pre></li>
<li>
<p>Let's say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p>
</li>
</ul>
<h3 id="the-stack">The Stack</h3>
<p>下面是栈的大概分布情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">		       <span class="o">+------------+</span>   <span class="o">|</span>
		       <span class="o">|</span> <span class="n">arg</span> <span class="mi">2</span>      <span class="o">|</span>   \
		       <span class="o">+------------+</span>    <span class="o">&gt;-</span> <span class="n">previous</span> <span class="n">function</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">stack</span> <span class="n">frame</span>
		       <span class="o">|</span> <span class="n">arg</span> <span class="mi">1</span>      <span class="o">|</span>   <span class="o">/</span>
		       <span class="o">+------------+</span>   <span class="o">|</span>
		       <span class="o">|</span> <span class="n">ret</span> <span class="o">%</span><span class="n">eip</span>   <span class="o">|</span>   <span class="o">/</span>
		       <span class="o">+============+</span>   
		       <span class="o">|</span> <span class="n">saved</span> <span class="o">%</span><span class="n">ebp</span> <span class="o">|</span>   \
		<span class="o">%</span><span class="n">ebp</span><span class="o">-&gt;</span> <span class="o">+------------+</span>   <span class="o">|</span>
		       <span class="o">|</span>            <span class="o">|</span>   <span class="o">|</span>
		       <span class="o">|</span>   <span class="n">local</span>    <span class="o">|</span>   \
		       <span class="o">|</span> <span class="n">variables</span><span class="p">,</span> <span class="o">|</span>    <span class="o">&gt;-</span> <span class="n">current</span> <span class="n">function</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">stack</span> <span class="n">frame</span>
		       <span class="o">|</span>    <span class="n">etc</span><span class="p">.</span>    <span class="o">|</span>   <span class="o">/</span>
		       <span class="o">|</span>            <span class="o">|</span>   <span class="o">|</span>
		       <span class="o">|</span>            <span class="o">|</span>   <span class="o">|</span>
		<span class="o">%</span><span class="n">esp</span><span class="o">-&gt;</span> <span class="o">+------------+</span>   <span class="o">/</span>
</code></pre></td></tr></table>
</div>
</div><p>根据发生错误的ip输出backtrace：通过链接脚本，将程序的符号表加载到elf文件中，具体可以参看<a href="http://sourceware.org/gdb/onlinedocs/stabs.html">stabs</a>。</p>
<h3 id="参考链接">参考链接</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>OS boot 的时候为什么要 enable A20？ - 坂本鱼子酱的回答 - 知乎 <a href="https://www.zhihu.com/question/29375534/answer/44137152">https://www.zhihu.com/question/29375534/answer/44137152</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>IO端口地址分布, <a href="http://web.archive.org/web/20040304063834/http://members.iweb.net.au/~pstorr/pcbook/book2/ioassign.htm">http://web.archive.org/web/20040304063834/http://members.iweb.net.au/~pstorr/pcbook/book2/ioassign.htm</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/mit6828-os%E5%AE%9E%E9%AA%8C/" term="mit6828 OS实验" label="mit6828 OS实验" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">嵌入式文件系统</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/filesystem/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" />
            <id>https://chengshuyi.github.io/posts/filesystem/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-21T14:11:20+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[嵌入式采用的存储设备一般是flash，由于flash同块设备有很较大的差异，因此并不能在flash设备上采用通用文件系统，比如Fat、Ext等等。现在对flash存储器……]]></summary>
            
                <content type="html"><![CDATA[<p>嵌入式采用的存储设备一般是flash，由于flash同块设备有很较大的差异，因此并不能在flash设备上采用通用文件系统，比如Fat、Ext等等。现在对flash存储器的文件系统越来越多了，主要可以分成两大类：一类是基于转译层和块的设备文件系统，另一类是基于日志结构的文件系统。</p>
<p>基于转译层的文件系统之所以称为基于转译层，是因为在文件系统和flash设备之间有一个中间层叫转译层。这个转译层可以将 Flash 设备模拟成块设备，以供文件系统控制和使用。而基于日志结构的文件系统又可以分为两大类：一类是通用的flash文件系统，一类是专用的flash文件系统。通用的文件系统可以在nor flash上运行，也可以在nand flash上运行。以 jffs为代表的文件系统就是这样的通用 flash文件系统。另一类专业的flash文件系统指的是专门针对flash的文件系统，以yaffs系列的文件系统为代表<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。 具体可以参看下图<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200422073948.png" alt=""></p>
<p>本文首先介绍了flash的特性，最后介绍了flash上常用的文件系统，以及对应的数据压缩技术、坏块管理技术、磨损均衡技术和垃圾回收技术。</p>
<h3 id="flash介绍12">flash介绍<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup><sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></h3>
<p>flash存储器，也叫快擦写存储器，和磁盘设备相比，flash存储器在体积、扩展性、耗电等方面都有着显著的优势，因此成为了嵌入式系统首选的存储设备。</p>
<p>flash属于非易失性半导体存储器，其类型目前主要两种：nor flash和nand flash。  nand flash广泛应用在各种存储卡、U盘、SSD、eMMC等等大容量设备中。nor flash 能快速随机读取，允许系统直接从存储器中读取代码执行即芯片内执行技术（eXecute In Place），而无需先将代码下载至RAM中再执行，可以像普通ROM一样执行程序。</p>
<p>flash存储器的擦除次数是有限的，一般是$10^6$次。当某块执行过度的擦除操作后，这一块的存储空间将会变为“只读”状态，不能再写入数据。flash存储器也存在着两个主要缺陷：</p>
<ul>
<li>一是在重写之前必须进行擦除，因为flash存储器划分成很多擦除块（sector-erase），对任何一位数据进行修改必须先擦除整个块（sector）；</li>
<li>二是擦除块的擦除次数有限，当一个块提前达到擦除次数上限时，将导致整个存储器无法使用。</li>
</ul>
<h4 id="nor-flash">nor flash</h4>
<p>Intel于1988年首先开发出nor flash存储器技术，这也是最早出现的flash存储器技术，目前主要由供应商Intel与AMD支持，主要应用于擦除和编程操作较少而直接执行代码的场合，尤其是纯代码存储应用的理想选择，如PC的BIOS固件、移 动电话、嵌入式系统中装载启动代码等。其特点如下：</p>
<ul>
<li>又名线性flash存储器；</li>
<li>能快速随机读取，允许系统直接从存储器中读取代码执行即芯片内执行技术（eXecute In Place），而无需先将代码下载至RAM中再执行；</li>
<li>可以单字节或单字编程，但不能单字节擦除，必须以块为单位或对整片进行擦除操作，重新编程之前需要先擦后写。因执行一个编程擦除操作时间较慢（大约5秒），而块尺寸又较大（64KB-128KB），于是在纯数据存储应用中花费的时间较长。</li>
</ul>
<h4 id="nand-flash">nand flash</h4>
<p>自1989年东芝公司开发出nand flash以来，如今主要由三星、富士通及东芝等日韩厂商大力支持，这种结构的存储器适合于数据和文件存储，主要作为SM卡、CF卡、PCMCIA卡、固态盘的存储介质，并正成存储器技术的核心。其特点如下：</p>
<ul>
<li>又名非线性flash存储器；</li>
<li>以页（256B-512B）为单位进行读和编程操作，以块(4KB-32KB)为单位进行擦除操作,编程擦除时间短一般每块时间为4ms；</li>
<li>实现串行读取，随机读取速度慢且不能按字节随机编程；</li>
<li>芯片尺寸小，引脚少，是位成本最低的固态存储器；</li>
<li>芯片包含有失效块，其数目最大可达到3-35块（取决于存储器密度），失效块虽不影响有效块的性能，但设计者仍需要在地址映射表中屏蔽它。</li>
</ul>
<h4 id="对比表格">对比表格</h4>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">nor flash</th>
<th align="center">nand flash</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">存储容量</td>
<td align="center">小，一般1MB-32MB</td>
<td align="center">大，一般8MB-512MB</td>
</tr>
<tr>
<td align="center">擦除块大小</td>
<td align="center">64KB-256KB</td>
<td align="center">6KB-128KB，每块被分为若干个512Bytes的页面，每页面含有16Bs附加存储区</td>
</tr>
<tr>
<td align="center">读写方式</td>
<td align="center">线形时间按字节随机读写</td>
<td align="center">以页面为单位读写，类似磁盘</td>
</tr>
<tr>
<td align="center">读写速度</td>
<td align="center">读取快，写入慢</td>
<td align="center">读取慢，写入快</td>
</tr>
<tr>
<td align="center">擦除时间</td>
<td align="center">慢，2s-5s/块</td>
<td align="center">快，2ms-5ms/块</td>
</tr>
<tr>
<td align="center">坏块比例</td>
<td align="center">低，出厂一般没有坏道</td>
<td align="center">高，出场可能有坏道</td>
</tr>
<tr>
<td align="center">价格</td>
<td align="center">低存储密度，尺寸大，价格高</td>
<td align="center">高存储密度，尺寸小，价格低</td>
</tr>
<tr>
<td align="center">接口形式</td>
<td align="center">接并行总线，内存接口</td>
<td align="center">接串行总线，I/O接口</td>
</tr>
<tr>
<td align="center">寿命</td>
<td align="center">十万次级</td>
<td align="center">百万次级</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">高，位交换几率低</td>
<td align="center">低，位交换几率高，必须采用错误探测/错误更正（EDC/ECC）算法</td>
</tr>
<tr>
<td align="center">XIP</td>
<td align="center">可以</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">易用性</td>
<td align="center">容易</td>
<td align="center">复杂，一般需要MTD驱动支持</td>
</tr>
<tr>
<td align="center">设计目的</td>
<td align="center">作为ROM的替代产品</td>
<td align="center">磁盘</td>
</tr>
<tr>
<td align="center">编程方式</td>
<td align="center">允许逐字节编程</td>
<td align="center">页面编程，且每个页面的编程次数有限制i</td>
</tr>
</tbody>
</table>
<h3 id="基于flash的文件系统">基于flash的文件系统</h3>
<p>flash存储器的擦除次数是有限的，一般是$10^6$次。当某块执行过度的擦除操作后，这一块的存储空间将会变为“只读”状态，不能再写入数据。根据以上特点，为了避免某些块的过度操作，而导致存储卡使用寿命降低，设计专门针对flash存储器的文件系统是必要的。嵌入式文件系统要考虑的特性<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>：</p>
<ul>
<li>数据压缩：通过压缩算法不仅可以降低数据的容量，而且间接的加速了I/O；</li>
<li>坏块管理：坏块通常使用带外区域中的特定标记来标识；</li>
<li>磨损均衡：由于flash存储芯片的擦除次数是有限制的，文件系统对存储器使用时必须充分考虑这个特性，因此最好能均匀使用存储芯片的每个扇区，以延长存储器的使用寿命。</li>
<li>垃圾回收：</li>
</ul>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200421232912.png" alt=""></p>
<h4 id="jffs23">jffs2<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></h4>
<p>jffs文件系统最早是由瑞典Axis Communications公司基于Linux2.0的内核为嵌入式系统开发的文件系统。jffs2是一个可读写的、压缩的、日志型文件系统，并提供了崩溃掉电安全保护，克服了jffs的一些缺点：使用了基于哈希表的日志节点结构,大大加快了对节点的操作速度；支持数据压缩；提供了“写平衡”支持；支持多种节点类型；提高了对flash存储器的利用率，降低了内存的消耗。它的缺点就是当文件系统己满或接近满时，运行会变慢，这主要是因为垃圾回收的问题。</p>
<h5 id="数据压缩">数据压缩</h5>
<p>jffs2提供了jffs所没有的数据压缩技术。数据在存放到flash之前会先被压缩，这个过程是由jffs2自动完成。因
此，在使用jffs2时无需自己对数据进行压缩。各种类型的压缩算法皆可内嵌到系统中去，目前jffs2使用的是zlib算
法。该算法比较适合ASCII文件，若压缩对象是二进制文件，压缩效果并不明显。</p>
<h5 id="坏块管理">坏块管理</h5>
<p>暂无</p>
<h5 id="磨损均衡">磨损均衡</h5>
<p>jffs并没有采用磨损均衡技术，到了jffs2才使用此技术。磨损均衡技术的引入提高了flash的使用寿命期限。jffs2改变了jfss没有块队列的状态，将flash各个块（block）分成三个队列：脏块队列（dirty_list）、干净块队列（clean_list）以及空闲块队列。脏块是指该块上至少有一个节点被标记为废弃（obsoleted）；干净块是指块上
的数据皆有效。工作流程如下：</p>
<ol>
<li>当系统的空闲块数小于6时，GC进程会被唤醒；</li>
<li>判断jiffies计数器的值，如果jiffies% 100非零，选中脏块队列。否则，将选中干净块队列。（很显然,如果存在脏块的话，选中后者的概率仅为1%。）</li>
<li>如果选中的是脏块队列，则直接进行擦写操作，最后把它挂接到空闲块队列；</li>
<li>如果选中的是干净块队列，则被选中的干净块中的所有数据要被全部移至其它空闲块中，接着对该块进行擦写操作，最后把它挂接到空闲块队列。</li>
</ol>
<h5 id="垃圾回收">垃圾回收</h5>
<p>jffs2的垃圾收集技术的原理：当需要增添新内容时，就在节点链表的末端添加新的节点存储新的内容；若要修改文
件的某部分，jffs2将该部分<strong>标记为废弃</strong>，并在节点<strong>链表末端添加修改后的内容</strong>。jffs2如此不断地在flash上添加新的内容，当flash上的存储空间用完时,系统就回收标记为废弃的空间，该过程就称为垃圾收集。垃圾收集进程(简称GC进程)专门负责该项工作。下面是jffs2 GC进程的工作流程：</p>
<ol>
<li>当系统的空闲块数小于6时，GC进程会被唤醒；</li>
<li>GC进程每次只回收一个空闲块；</li>
<li>如果此时flash上的空闲块数仍小于6，那么GC进程必须再回收一个空闲块，直到总的空闲块数达到6为止。</li>
</ol>
<h5 id="断电保护">断电保护</h5>
<p>断电保护技术的实现依赖于jffs2的日志式存储结构。当系统遭受不正常断电后重新启动时，jffs2自动将系统恢复到断电前最后一个稳定状态。</p>
<h4 id="yaffs27">yaffs2<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></h4>
<h5 id="数据压缩-1">数据压缩</h5>
<p>暂无</p>
<h5 id="坏块管理-1">坏块管理</h5>
<p>暂无</p>
<h5 id="磨损均衡-1">磨损均衡</h5>
<p>yaffs2 并未实现真正的磨损均衡算法，而是通过<strong>顺序写策略和串行块分配策略</strong>将擦除次数尽可能均匀地分布在闪存空间上，测试结果表明其均衡效果较好，但忽略了静态数据和“冷”数据的影响，因此是一种局部的磨损均衡机制，有待进一步的改进。</p>
<p>顺序写策略：</p>
<p>串行块分配策略：</p>
<h5 id="垃圾回收-1">垃圾回收</h5>
<p>yaffs2垃圾回收操作一般在向文件写数据（函数 yaffs_wr_data_obj）、更新对象头（函数 yaffs_update_oh）和文件截短操作（函数 yaffs_resize_file）等过程中被调用，由函数yaffs_check_gc视当前闪存空间使用情况决定是否触发垃圾回收操作。YAFFS2 的垃圾回收操作分三步进行：</p>
<ol>
<li>查找到满足回收条件的目标回收块（由函数yaffs_find_gc_block 函数完成），若未找到，则退出；</li>
<li>遍历块中所有页，若页中存放有效数据，则将数据复制到其它块中的空闲页中，然后删除该页，并修改内存中记录闪存空间使用信息的数据结构（如块信息结构 yaffs_block_info，页位图数组 chunk_bits 等）以体现
闪存空间使用情况的变化（由函数 yaffs_gc_process_chunk 完成）；</li>
<li>当块中所有 chunk 都被删除后，则擦除该块（由函数 yaffs_block_became_dirty 完成），使其可以被再次写入数据。</li>
</ol>
<h4 id="ubifs4">ubifs<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h4>
<p>ubifs文件系统主要包含ubifs和ubi模块，ubifs模块建立在ubi模块的基础上，ubi模块是建立在mtd模块基础上的。三个模块整体关系如下图<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200421234706.png" alt=""></p>
<p>ubifs的设计主要是为了解决jffs2文件系统存在的启动时间长、系统扩展性差、内存消耗量大、损耗均衡处理能力差等问题。jffs2的挂载时间是与闪存大小成线性比的（扫描所有的块），ubifs克服了这一弱点（ubi子模块挂载时间还是与闪存大小成线性比的）。</p>
<p>ubifs同jffs2的三个主要区别：</p>
<ul>
<li>jffs2将索引（inode）节点存储在内存上，ubifs将索引节点存储在闪存上 ；</li>
<li>jffs2运行在MTD设备层之上，ubifs运行在ubi层之上；</li>
<li>jffs2不支持回写（write-back），而ubifs支持回写技术。</li>
</ul>
<h5 id="坏块管理-2">坏块管理</h5>
<p>ubi在两种情况下认为peb（physical erase block）已损耗：</p>
<ul>
<li>写peb失败，此时，ubi把这个peb的数据搬移到其他的peb，然后诊断该peb是否出现为坏块，如果是，标记为坏块；</li>
<li>擦除操作出现I/O错误，在这种情况下，直接把peb标记为坏块。</li>
</ul>
<h5 id="磨损均衡-2">磨损均衡</h5>
<p>暂无</p>
<h5 id="垃圾回收-2">垃圾回收</h5>
<p>暂无</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>周林. 通用嵌入式文件系统YAFFS的移植[D]. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>冯子陵. 闪存文件系统UBIFS的分析与优化[D]. 2013. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/Toshiba%20NAND_vs_NOR_Flash_Memory_Technology_Overviewt.pdf">NAND vs. NOR Flash MemoryTechnology Overview</a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>孙健. 基于Flash存储器的嵌入式文件系统的研究与实现[D]. 西安电子科技大学. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>李桂良, 刘发贵. JFFS2文件系统的关键技术及其在嵌入式系统的应用[J]. 计算机应用, 2003(07):137-139. <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>[优质文章]李恒恒. 基于YAFFS2文件系统的NAND Flash存储管理关键技术研究[D]. <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" term="文件系统" label="文件系统" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" term="文件系统" label="文件系统" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">进程虚拟地址空间</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-04T19:31:04+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[进程地址空间布局 下图是虚拟地址空间分布1。 我们的运行文件是elf格式的，在我们运行程序时，linux通过load_elf_binary函数建立上图的地址空间。 内存描述符……]]></summary>
            
                <content type="html"><![CDATA[<h3 id="进程地址空间布局">进程地址空间布局</h3>
<p>下图是虚拟地址空间分布<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/p803C.png" alt="虚拟地址空间内存分布"></p>
<p>我们的运行文件是elf格式的，在我们运行程序时，linux通过<code>load_elf_binary</code>函数建立上图的地址空间。</p>
<h3 id="内存描述符mm_struct">内存描述符mm_struct</h3>
<p>内核使用内存描述符结构体表示进程的地址空间，该结构包含了和进程地址空间有关的全部信息。内存描述符由<code>struct mm_struct</code>结构体表示。下面给出内存描述符的结构和各个域的描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">mm_struct</span> <span class="p">{</span> 
    <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">mmap</span><span class="p">;</span> 		<span class="cm">/* 虚拟内存区域列表 */</span> 
    <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">mm_rb</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">mmap_cache</span><span class="p">;</span> <span class="cm">/* 上一次find_vma的结果 */</span> 
	<span class="p">...</span> 
    <span class="c1">// 地址空间的各种段：栈段、mmap、堆...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>mmap</code>成员使用单独链表连接所有的内存区域对象，所有的区域按地址增长的方向排序，mmap域指向链表中第一个内存区域。<code>mm_rb</code>域使用红一黑树连接所有的内存区域对象。mm域指向红一黑树的根节点。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200329094122782.png" alt=""></p>
<h3 id="虚拟内存区域vm_area_struct">虚拟内存区域vm_area_struct</h3>
<p><code>struct vm_area_struct</code>结构体描述了指定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，比如访问权限等，另外，相应的操作也都一致。按照这样的方式，每一个VMA就可以代表不同类型的内存区域~~（比如内存映射文件或者进程用户空间栈）~~，下面给出该结构定义和各个域的描述；</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200406175943.png" alt=""></p>
<h4 id="查找vma">查找VMA</h4>
<ol>
<li><code>find_vma</code>函数：该函数在指定的地址空间中搜索第一个<code>vm_end</code>大于addr的内存区域。换句话说，该函数寻找第一个包含addr或首地址大于addr的内存区域，如果没有发现这样的区域，该函数返回NULL。否则返回指向匹配的内存区域的<code>vm_area_struct</code>结构体指针。注意，由于返回的VMA首地址可能大于addr，所以指定的地址并不一定就包含在返回的VMA中。因为很有可能在对某个VMA执行操作后，还有其他更多的操作会对该VMA接着进行操作，所以<code>find_vma()</code>函数返回的结果被缓存在内存描述符的<code>mmap_cache</code>域中。</li>
<li><code>find_vma_prev</code>函数：返回第一个首地址小于addr的VMA。</li>
<li><code>find_vma_intersection</code>函数：返回第一个和指定地址区间相交的VMA。</li>
</ol>
<h4 id="创建vma">创建VMA</h4>
<p>内核使用<code>do_mmap()</code>函数创建一个新的线性地址区间。但是说该函数创建了一个新VMA并不非常准确，因为如果创建的地址区间和一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，两个区间将合并为一个。如果不能合并，就确实需要创建一个新的VMA了。</p>
<h4 id="删除vma">删除VMA</h4>
<p>undone</p>
<h3 id="堆的管理">堆的管理</h3>
<h3 id="参考链接">参考链接</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://stackoverflow.com/questions/32746996/how-linux-process-address-space-is-stored">How “linux process address space” is stored?</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 人工势场法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E4%BA%BA%E5%B7%A5%E5%8A%BF%E5%9C%BA%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E4%BA%BA%E5%B7%A5%E5%8A%BF%E5%9C%BA%E6%B3%95/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-04T10:02:06+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[人工势场法，即Artificial Potential Field，最早于20世纪80年代中期，由Khatib和Krogh提出的一种虚拟力法，其基本思想是将机器人在环境中的运动视为一种虚拟……]]></summary>
            
                <content type="html"><![CDATA[<p>人工势场法，即Artificial Potential Field，最早于20世纪80年代中期，由Khatib和Krogh提出的一种虚拟力法，其基本思想是将机器人在环境中的运动视为一种虚拟的人工受力场中的运动，其中障碍物对机器人产生斥力，而目标点对机器人产生引力，引力和斥力的合力作为机器人的加速力来控制机器人的运动方向和计算机器人的位置。</p>
<p>人工势场法具有结构简单、易于理解、便于实现实时控制的优点。其缺点也非常明显，比较容易陷入局部极小值问题，即机器人受到的合力为零，机器人停止运动，但却没有到达目标位置，陷入局部极小值。对于编队机器人数量比较大或者编队处于复杂环境中时，极小值问题显得尤为突出。此外，应用人工势场法的主要工作在于势函数的设计，对于未知环境中无法得知障碍物的尺寸、形状，这使得很难选取合理的势场点，进而很难设计出良好的势函数。基于这个原因，目前人工势场法主要用于全局环境已知情况下的多机器人编队。</p>
<p>下图中包括多机器人，障碍物和目标物，目标位置势场最低，即其虚拟重力势能是最小的,机器人的最初处于较高的位置因此具有较大的重力势能，环境中的障碍物可以看成为重力场中的凸点,因此机器人由于重力势能从初始位置运动到目标位置的过程可以看成<strong>从高处向低处</strong>运动的物体。环境中虚拟的势场用等势线的形式表现出来，即图中的密集分布的曲线上的势场都是相等的。因此容易得到如果机器人的运动模型是<strong>完整约束</strong>的，则机器人的理想运动曲线应该是<strong>垂直于所有的等势线</strong>的。然而因为机器人模型和障碍物形状的不规则，使得势场法在实际应用中存在一定的缺陷<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200405135443.png" alt=""></p>
<p>机器人群集的基本特征：避障避碰、速度匹配和群集中心。相对的，在多机器人群集势场包含三个基本特征，因此可设$U_{obstacle}(q)$为障碍物产生的势场,$U_{neighbor}(q)$为群集中周围邻域的机器人产生的势场，$U_{centre}(q)$为群集中心产生的势场，另外群集运动目标产生的势场为$U_{goal}(q)$，其中q表示机器人的当前位置。进行势场叠加后可得：</p>
<div>
$$
U_{\Sigma}(q)=\underbrace{U_{\text {goal }}(q)+U_{\text {centre }}(q)}_{\text {引力势场 }}+\underbrace{\sum U_{\text {obstacles }}(q)}_{\text {斥力势场 }}+\underbrace{\sum U_{\text {neighbors }}(q)}_{\text {引力/斥力同时存在 }}\\
F(q) = -\nabla U_{\Sigma}(q)
$$
</div>
$U_{\Sigma}(q)$表示机器人在环境中$q$位置时的综合势场，$F(q)$则表示势场中的势场力，方向沿势场的负梯度方向。
<p>在通常情况下，对于机器人而言环境地图一般都是未知的，常用的策略是传感器对环境进行实时感知并获得局部的位置信息，以进行决策，因此基于这种反应式的势场反馈导航原理如下图所示：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200405140801.png" alt=""></p>
<h3 id="目标势场和障碍物势场">目标势场和障碍物势场</h3>
<p>目标势场体现一种全局的引力效应，即势场存在于环境中一切位置，表现出来的特性为机器人离目标点越远，引力越大，按照这种规律可以建立目标势场函数：</p>
<div>
$$
\left\{\begin{array}{ll}
U_{goal}(x) = \frac{1}{2}k(x-x_{goal})^2\\
F_{goal}(x) = -k\|x-x_{goal}\|
\end{array}\right.
$$
</div>
其中$x_{goal}$为目标点位置，$x$为机器人的实时位置。因此目标点的引力势场通常是基于全局地图的，即机器人和目标点在全局地图中的位置己知，或者机器人
与目标点的相互关系己知为前提。
<p>相对的，障碍物势场为局部排斥力效应，即当且仅当机器人与障碍物之间的距离小于某定值时，才会有斥力势场的存在，而通常情况下要建立具有障碍物的环境地图，尤其是当环境中的障碍物变化的时候，全局地图的建立比较困难，通常采用基于外部传感器的反应式避障。设$f(x)$为当机器人处于$x$位置时激光探测距离，常数$d$为斥力场范围,因此当$f(x)&lt;d$时机器人将受到斥力场的作用。</p>
<div>
$$
\left\{\begin{array}{ll}
U_{\text {obs }}(x)=\left\{\begin{array}{ll}
\frac{\eta}{2}\left(\frac{1}{f(x)}-\frac{1}{d}\right)^{2} & f(x) \leq d \\
0 & f(x)>d
\end{array}\right. \\
F_{\text {obs }}(x)=\left\{\begin{array}{ll}
\|\left(\frac{1}{f(x)}-\frac{1}{d}\right) \frac{\eta \cdot \partial f}{f^{2} \cdot \partial x} \| & f(x) \leq d \\
0 & f(x)>d
\end{array}\right.
\end{array}\right.
$$
</div>
<h3 id="邻域机器人势场">邻域机器人势场</h3>
<p>借用物理学中对微小粒子（如分子，原子）的引力和斥力的关系，来描述邻域机器人的势场规律。假设机器人$i$与$j$相邻，则$i$相对$j$的势场函数和势场力函数分别为：</p>
<div>
$$
\left\{\begin{array}{l}
U_{n e i g}\left(x_{i} | x_{j}\right)=\frac{\mu}{2} \ln ^{2} \frac{\left\|x_{i}-x_{j}\right\|}{\delta}=\frac{\mu}{2} \ln ^{2} \frac{\left\|r_{i j}\right\|}{\delta} \\
F_{\text {neig }}\left(x_{i} | x_{j}\right)=-\frac{\mu \cdot \delta}{\left(x_{i}-x_{j}\right)} \cdot \ln \frac{|| x_{i}-x_{j} \|}{\delta}=-\frac{\mu \cdot \delta}{r_{i j}} \cdot \ln \frac{\left\|r_{i j}\right\|}{\delta}
\end{array}\right.
$$
</div>
可以得到该势场函数和势场力函数对应的曲线：
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200405142530.png" alt=""></p>
<h3 id="群集中心势场">群集中心势场</h3>
<p>在群集中除了目标点、障碍物以及邻域机器人这些可见的势场源外，还存在一种无形的吸引势场使得机器人朝某群集中心聚拢，该势场就是群集中心产生的
势场。首先群集中心本来就是一个非实体的概念，一般将群体的几何中心作为机
器人的群集中心，这样可以缩短机器人聚拢的距离，因此如果设群集中机器人的
个数为$M$个，则群集的几何中心为：</p>
<div>
$$
\bar{x}=\sum_{1}^{M} x_{j} / M
$$
</div>
由于同为引力场，所以类似目标点的势场函数规律可得群集中心的势场和势场力满足：
<div>
$$
\left\{\begin{array}{ll}
U_{centre}(x) = \frac{1}{2}c\|x-\bar{x})^2\| \\
F_{centre}(x) = -c(x-\bar{x})
\end{array}\right.
$$
</div>
<!--省略了部分-->
<h3 id="参考文献">参考文献</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>刘磊. 多移动机器人编队及协调控制研究[D]. 华中科技大学, 2009. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 基于图论的方法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E8%AE%BA%E7%9A%84%E6%96%B9%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E8%AE%BA%E7%9A%84%E6%96%B9%E6%B3%95/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-04T10:00:47+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[基于图论的方法研究多机器人编队，需要将队形信息转换成各种图，依靠图论知识及李雅普诺夫方法分析编队的稳定性，得出队形的控制策略。该方法中机器人编队队形是依据图论理论中图的……]]></summary>
            
                <content type="html"><![CDATA[<p>基于图论的方法研究多机器人编队，需要将队形信息转换成各种图，依靠图论知识及李雅普诺夫方法分析编队的稳定性，得出队形的控制策略。该方法中机器人编队队形是依据图论理论中图的节点与边的关系来描述。节点即表示机器人的运动学特性，即是对运动方式的描述，而边则表示机器人之间的关系，是对运动的约束，利巧相应的图论知识与控制理论知识研究编队队形控制输出具有一致性。基于图论法的优点在于图的形状可任意变化，队形描述也相对简单，编队中改变队形较容易，并且图论的相关理论研究比较成熟，但不足之处在于物理实现比较复杂，通常只能适用于仿真环境的理论研究<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p>用图论的方法描述车辆编队，这种表示方法能够唯一的（无二义性的）定义多车辆编队队形，准确反映出编队中各车辆间的相互作用关系。车辆队表示为图$G=(V,E)$，其中，V 表示图的结点集，代表车辆集$V={1,2,...,N_a}$ } ； E 表示图的边集，其中的边元素是相关车辆 $i,j\in V$ 间的一个有序数对$(i,j)\in E$，表示车辆间的连接关系，对于有$N_a$个车辆的系统，至少用$M=N_a-1$个向量就可以对车辆编队进行唯一描述。编队图被认为是无方向的，所以$(i,j)\in E,(j,i)\in E$，如$(i,j)\in E$，那么车辆 i 和 j就被称为相邻车辆，车辆$i$的相邻车辆集表示为$N_i\in V$。另外，为了保证车辆编队沿给定的路径运行，所以将编队中与寻径相关的车辆定义为核心车辆。尽管在编队中任意两个核心车辆之间可能没有相关向量，但我们认为核心车辆间均为相邻车辆关系，因为它们之间通过寻径目标耦合<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>两相邻车辆$i $和$j$间的期望相关向量表示为$d_{ij}\in R^n$，它表示处于期望编队路径位置时，两相邻车辆间的距离。</p>
<p>给定了编队图$G=(V,E)$和编队路径$q_{ref}$后，就可以定义出编队向量$F=(f_1,...,f_{M+1})\in R^{n(M+1)}$它的分量$f_1\in R^n$定义如下：</p>
<div>
$$
f_l = q_i-q_j+d_{ij},\forall l=1,...,M\\
f_{M+1}=q_{\Sigma}-q_d
$$
</div>
其中$i$表示构成边$e_l$的尾结点，$j$表示构成边$e_l$的头结点。$q_{\Sigma}$表示当前车辆的几何中心，$q_d$表示期望的车辆几何中心。很明显，当$F\equiv 0$时车辆组成编队，得到从$q$到$F$的映射关系：
<div>
$$
F=Gq+\hat{d}, G^T=[C_{(n)}\quad V]\\
\hat{d}=(...,d_{ij},...,-q_d)\\
V^T=[V_1...V_{N_a}]\in R^{n\times n\times N_a}
$$
</div>
$V_i\in R^{n\times n}$定义如下，
<div>
$$
Vi=\left\{\begin{array}{ll}
\frac{1}{N_a}I_{(n)} \quad if \quad i=1,2,...,N_a\\
0\quad otherwise
\end{array}\right.
$$
</div>
矩阵$C_{n}\in R^{n(N_a\times M)}$与关联矩阵$C\in R^{N_a\times M}$有关，其中$C=[c_{ij}]$的元素根据边集$E$的元素定义如下，
<div>
$$
c_{ij} = \left\{\begin{array}{ll}
+1, i为尾结点\\
-1,i为头节点\\
0,其它
\end{array}\right.
$$
</div>
根据以上的定义，当$G_{q^c}=-\hat{q}$ 时就能够计算出每个车辆的期望运行轨线。
<h3 id="参考文献">参考文献</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>岑斌斌. 多机器人编队的分布式协同控制方法研究[D]. 南京大学, 2015. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>贺晨龙, 黄丽湘, 张继业. 多车辆编队协作控制[C]// 全国非线性振动、全国非线性动力学和运动稳定性学术会议. 2007. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 基于行为的方法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%96%B9%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%96%B9%E6%B3%95/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-04T09:11:07+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[基于行为的方法的主要思想是将编队任务转换为一系列具有特定功能的基本运动行为，这些基本运动行为是机器人运动的最小运动单位，例如，向左转、前进、奔向目标、姿态调整、蔽障、沿……]]></summary>
            
                <content type="html"><![CDATA[<p>基于行为的方法的主要思想是将编队任务转换为一系列具有特定功能的基本运动行为，这些基本运动行为是机器人运动的最小运动单位，例如，向左转、前进、奔向目标、姿态调整、蔽障、沿墙运动、目标导航等等。基于行为的方法通常由两部分组成，分别是基本<strong>行为设计</strong>部分和<strong>行为选择</strong>设计部分。对编队中的每个机器人而言，机器人的输入可以是自身传感器的探测信息，也可以是通过通信获取编队中其它某个或者多个机器人的行为输出，行为选择设计部分根据机器人输入信息使得机器人选择对应的基本行为（以一定角速度和线速度的方式）进行输出，从而使得机器人处于编队中理想的位置<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，具体如下图所示：</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200404112052576.png" alt=""></p>
<p>基于行为方法的编队控制包括以下三种控制方法<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>：</p>
<ol>
<li>行为抑制法：首先对每个行为进行优先级排序，这样当无人车需要同时执行多个行为时，无人车就会按照优先级顺序执行优先级最高的行为。</li>
<li>加权平均法：首先对每个行为规定一个对应的权值，根据对应行为的重要程度设置对应的权值。这样当无人车需要同时执行多个行为时，无人车会计算所有行为的加权求和，得到的结果经过正则化后作为无人车的行为控制；</li>
<li>模糊逻辑法：当无人车需要同时执行多个行为时，通过查看模糊规则表，执行相对的行为控制。</li>
</ol>
<p>基于行为的方法是一种分布式的控制方法，该方法具有柔性好的特点，能够在编队中动态的添加或者减少机器人的数量，同时该方法使得机器人表现出一定的智能性，类似于人或者其它高等动物的感官反应或者决策思维，更容易被人们所理解和认识。其缺点是难以设计出合适的运动行为以及难以对系统进行数据建模和系统稳定性分析，由于缺乏相关数学理论，对于设计的运动行为会对编队的稳定性造成什么影响目前仍然无法得知，只能通过实践证明，同时，在复杂环境下的机器人的输出行为是难以预见的，这使得该方法的灵活性不高。目前该方法主要运用于较大规模的编队队形、跟踪、空中多飞行器编队、包围入侵者、大面积区域搜索等。</p>
<h3 id="基于位姿误差的机器人编队基本运动行为设计3">基于位姿误差的机器人编队基本运动行为设计<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></h3>
<h4 id="机器人运动学模型">机器人运动学模型</h4>
<p>二维空间机器人位置和姿态表示为：</p>
<div>
$$
q_0=[x_0\quad y_0\quad \theta_0]^T
$$
</div>
假设机器人当前的线速度$v_0$和角速度$\omega_0$，可得移动机器人的位姿$\dot{q}$：
<div>
$$
\dot{\boldsymbol{q}}_{0}=\left[\begin{array}{c}
\dot{x}_{0} \\
\dot{y}_{0} \\
\dot{\theta}_{0}
\end{array}\right]=\left[\begin{array}{cc}
\cos \theta_{0} & 0 \\
\sin \theta_{0} & 0 \\
0 & 1
\end{array}\right]\left[\begin{array}{l}
v_{0} \\
\omega_{0}
\end{array}\right]
$$
</div>
#### 位姿误差描述
<p>虚拟结构仅被用以描述<strong>目标编队的形状</strong>和编队中虚拟机器人的固定位置，而<strong>非限制该位置上真实存在的机器人</strong>。如下图所示：机器人团队由领航者$q_L(x_L,y_L,\theta_L)$和跟随者$q_{F2}(x_{F2},y_{F2},\theta_{F2})$、$q_{F3}(x_{F3},y_{F3},\theta_{F3})$组成。虚线空心图形表示编队中的虚拟机器人，即跟随者$q_{F2}$和$q_{F3}$和应当抵达的位置，表示为$q_{T2}(x_{T2},y_{T2},\theta_{T2})$、$q_{T3}(x_{T3},y_{T3},\theta_{T3})$。$q_L$与$q_{T2}$、$q_{T3}$共同组成虚拟的三角形编队。设计的行为应该能够确保跟随者$q_{F2}$和$q_{F3}$到达编队中$q_{T2}$、$q_{T3}$的位置。那么可以通过$q_{F2}$和$q_{T2}$之间的位置关系描述位姿误差。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200404142240713.png" alt=""></p>
<p>最终通过公式推导可以得到：</p>
<div>
$$
\boldsymbol{e}_{FiTj}=\left[\begin{array}{c}
e_{FiTj}^{x} \\
e_{FiTj}^{y} \\
e_{FiTj}^{\theta}
\end{array}\right]=\left[\begin{array}{ccc}
\cos \theta_{F i} & \sin \theta_{F i} & 0 \\
-\sin \theta_{F i} & \cos \theta_{F i} & 0 \\
0 & 0 & 1
\end{array}\right]\left(\boldsymbol{q}_{T j}-\boldsymbol{q}_{F i}\right), i, j \in[2, n]
$$
</div>
上式中，$\bold{q}_{Tj}$为通过传感器或通信获取的虚拟目标机器人的位姿，$\bold{q}_{Fi}$为机器人自身的位姿信息，主要通过如GPS、编码器等传感器获得。为了使$\bold{e}_{FiTj}$处于一定的阈值内，设计了两种基本运动行为与作为基本运动行为的选择依据的三种描述性行为。两种基本行为是直线运动与旋转运动。设计的思想是首先机器人采用旋转运动面向目标，然后采用直线运动奔向目标，最后通过旋转和目标完全重合，此时机器人到达编队中虚拟机器人的位置。当所有机器人均完成此任务时，编队形成。上述思想可以归纳为转向目标，奔向目标与姿态调整三种描述性行为。
<p>令阈值为：$\boldsymbol{\delta} = [\delta_p\quad \delta_p\quad \delta_o]^T$，$\delta_p$表示位置误差常数，$\delta_o$表示姿态角度误差常数，$T$为实际需要的有限时间。</p>
<h4 id="行为选择">行为选择</h4>
<ul>
<li>转向目标</li>
</ul>
<p>当机器人与虚拟目标之间的$y$方向误差$|e^y_{FiTj}|&gt;\delta_p$，时，虚拟机器人$q_{Tj}$在跟随机器人$q_{Fi}$运动的正前方的时候，机器人选择奔向目标的行为。该行为同时考虑了当$q_{Fi}$背离$q_{Tj}$且两者在同一直线上的情况，此时$|e^y_{FiTj}|&lt;\delta_p,e^x_{FiTj}&lt;0$。该行为的触发条件：</p>
<div>
$$
\bigcup\left\{\begin{array}{l}
\left|e_{F i T j}^{y}\right| \geq \delta_{p} \\
e_{F i T j}^{x}<-\delta_{p}\left(\left|e_{FiTj}^{y}\right|<\delta_{p}\right) i, j \in[2, n]
\end{array}\right.
$$
</div>
转向目标行为的结束条件为：
<div>
$$
\lim _{t \rightarrow t_{F i T j}^{T T}}\left|e_{F i T j}^{y}(t)\right|<\delta_{P}, \quad e_{F i T j}^{x} \geq \delta_{P}, i, j \in[2, n]
$$
</div>
<ul>
<li>奔向目标</li>
</ul>
<p>当虚拟机器人$q_{Tj}$在跟随机器人$q_{Fi}$运动的正前方，即$|e^y_{FiTj}|&lt;\delta_p$时，机器人选择奔向目标的行为。奔向目标行为用于缩短虚拟机器人$q_{Tj}$与跟随机器人$q_{Fi}$之间的直线距离。该行为的触发条件：</p>
<div>
$$
|e^y_{FiTj}|<\delta_p, |e^x_{FiTj}|\geq\delta_p, i,j\in[2,n].
$$
</div>
奔向目标行为的结束条件为：
<div>
$$
|e^y_{FiTj}|<\delta_p, \lim _{t \rightarrow t_{F i T j}^{T T}}|e^x_{FiTj}|(t)<\delta_p, i,j\in[2,n].
$$
</div>
<ul>
<li>姿态调整</li>
</ul>
<p>当虚拟机器人$q_{Tj}$与跟随机器人$q_{Fi}$之间的距离误差分量$|e^x_{FiTj}|&lt;\delta_p$，$|e^y_{FiTj}|&lt;\delta_p$，且两者方向误差值$|e^\theta_{FiTj}|&gt;\delta_o$的时候，机器人选择姿态调整行为。姿态调整行为是为了让近似处于同一点上的$q_{Tj}$与$q_{Fi}$完成角度的重合。该行为的触发条件：</p>
<div>
$$
|e^x_{FiTj}|<\delta_p, |e^y_{FiTj}|<\delta_p, |e^\theta_{FiTj}|\geq\delta_o,i,j\in[2,n].
$$
</div>
姿态调整行为的结束条件为：
<div>
$$
|e^x_{FiTj}|<\delta_p, |e^y_{FiTj}|<\delta_p, \lim _{t \rightarrow t_{F i T j}^{T T}}|e^\theta_{FiTj}|(t)<\delta_o,i,j\in[2,n].
$$
</div>
<h3 id="参考文献">参考文献</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>陈传均. 多机器人领航—跟随型编队控制研究[D]. 杭州电子科技大学. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>王京.多智能体系统编队避障算法研究[D].上海:华东理工大学,2013. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>刘磊. 多移动机器人编队及协调控制研究[D]. 华中科技大学, 2009. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">c语言运算符</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/c/%E8%BF%90%E7%AE%97%E7%AC%A6/" />
            <id>https://chengshuyi.github.io/posts/c/%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-03T17:25:34+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[本文主要汇总了c语言的一些运算符，因此我们能对运算符有全局的认识。 运算符 名称 算术运算符 +, -, *, /, % 移位运算符 &gt;&gt;, &lt;&lt; 位运算符 &amp;, |, ^ 赋值运算符 = 复合赋值运算符 +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=……]]></summary>
            
                <content type="html"><![CDATA[<p>本文主要汇总了c语言的一些运算符，因此我们能对运算符有全局的认识。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">算术运算符</td>
<td align="center"><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></td>
</tr>
<tr>
<td align="center">移位运算符</td>
<td align="center"><code>&gt;&gt;</code>, <code>&lt;&lt;</code></td>
</tr>
<tr>
<td align="center">位运算符</td>
<td align="center"><code>&amp;</code>, <code>|</code>, <code>^</code></td>
</tr>
<tr>
<td align="center">赋值运算符</td>
<td align="center"><code>=</code></td>
</tr>
<tr>
<td align="center">复合赋值运算符</td>
<td align="center"><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code></td>
</tr>
<tr>
<td align="center">单目运算符</td>
<td align="center"><code>!</code>, <code>++</code>, <code>-</code>, <code>&amp;</code>, <code>sizeof</code>, <code>~</code>, <code>--</code>, <code>+</code>, <code>*</code>, <code>强制类型转换</code></td>
</tr>
<tr>
<td align="center">关系运算符</td>
<td align="center"><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code>, <code>==</code></td>
</tr>
<tr>
<td align="center">逻辑运算符</td>
<td align="center"><code>&amp;&amp;</code>, <code>||</code></td>
</tr>
<tr>
<td align="center">条件运算符</td>
<td align="center"><code>a?b:c</code></td>
</tr>
<tr>
<td align="center">逗号运算符</td>
<td align="center"><code>,</code></td>
</tr>
<tr>
<td align="center">下标运算符</td>
<td align="center"><code>[]</code></td>
</tr>
<tr>
<td align="center">函数运算符</td>
<td align="center"><code>()</code></td>
</tr>
<tr>
<td align="center">结构成员运算符</td>
<td align="center"><code>.</code>, <code>-&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="算术运算符">算术运算符</h3>
<p>算术运算符包括：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>，它们也都是双目运算符。</p>
<blockquote>
<p>注意同单目运算符中的<code>+</code>, <code>-</code>, <code>*</code>区分开来，算术运算符时双目运算符，所以使用它们时并不会造成语义上的歧义。</p>
</blockquote>
<h3 id="--移位运算符--"><!--移位运算符--></h3>
<!--`>>`, `<<`-->
<h3 id="--位运算符--"><!--位运算符--></h3>
  <!--`&`, `|`, `^`-->
<h3 id="--赋值运算符--"><!--赋值运算符--></h3>
<!--`=`-->
<!--复合赋值运算符：`+= -= *= /= %= <<= >>= &= ^= |=-->`
<h3 id="单目运算符">单目运算符</h3>
<p>单目运算符包括：<code>!</code>, <code>++</code>, <code>-</code>, <code>&amp;</code>, <code>sizeof</code>, <code>~</code>, <code>--</code>, <code>+</code>, <code>*</code>, <code>强制类型转换</code></p>
<ul>
<li>
<p>经过<code>!</code>的数值只有两种结果：
$$
!a=\left{\begin{array}{cc}
0,a\neq0 \<br>
1,a=0
\end{array}\right.
$$</p>
</li>
<li>
<p><code>~</code>会对所有的位取反，包括符号位：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">~</span><span class="n">a</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//-1
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>sizeof</code>的参数可以是数组、指针、类型、对象、函数等，其作用是计算静态对象的内存大小；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// sizeof的宏定义原型：#define sizeof(L_Value) ((char*)(&amp;L_Value + 1) - (char*)(&amp;L_Value))
</span><span class="c1"></span>  
<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">a_ptr</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">a_ptr</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a_ptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 
    <span class="c1">//这里可以看出数组和指针并非完全相等，编译器对其处理的方式还是不同的。
</span><span class="c1"></span>    <span class="c1">//0x62fdb0 0x62fdb0
</span><span class="c1"></span>    <span class="c1">//100 8
</span><span class="c1"></span><span class="p">}</span>
  
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="--关系运算符--"><!--关系运算符--></h3>
<!--`> >= < <= != ==-->`
<h3 id="--逻辑运算符--"><!--逻辑运算符--></h3>
<!--`&& ||`-->
<h3 id="--条件运算符--"><!--条件运算符--></h3>
<!--?;-->
<h3 id="--逗号运算符--"><!--逗号运算符--></h3>
<!--都好运算符将多个表达式分隔开来，这些表达式自左向右逐个进行求值-->
<h3 id="--下标运算符--"><!--下标运算符--></h3>
<!--[]-->
<h3 id="--函数运算符--"><!--函数运算符--></h3>
<!--()-->
<h3 id="--结构成员运算符--"><!--结构成员运算符--></h3>
<!--`.` ->-->
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/c%E8%AF%AD%E8%A8%80/" term="c语言" label="c语言" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/c%E8%AF%AD%E8%A8%80/" term="c语言" label="c语言" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/" term="c语言运算符" label="c语言运算符" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">伙伴系统</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-03T15:26:04+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[伙伴算法是一种动态存储分配算法，用于实现操作系统内核空间和用户空间 (如 C 语言库) 的分配和回收操作.。Knowlton和 Knuth最早系统地描述了用于内存管理中的二分伙伴……]]></summary>
            
                <content type="html"><![CDATA[<p>伙伴算法是一种动态存储分配算法，用于实现操作系统内核空间和用户空间 (如 C 语言库) 的分配和回收操作.。Knowlton和 Knuth最早系统地描述了用于内存管理中的二分伙伴算法。之后，Hirschberg和Shen先后提出斐波那契伙伴算法和加权伙伴算法，作为伙伴算法的两种变体。为了适应不同的内存请求概率分布，Peterson又进一步提出泛化伙伴算法，针对不同请求概率分布采取不同的分配策略。为了追求时间效率，Linux 内核选择实现了二分伙伴算法, 该算法的优点在于伙伴地址的计算更加简便、高效<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p>Linux内核伙伴系统算法把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续页框的页框块。最大可以申请1024个连续页框，也即4MB大小的连续空间。假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了即将页框分为两个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中。如果512个页框的链表中仍没有空闲块，继续向1024个页框的链表查找，如果仍然没有，则返回错误<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>下图是伙伴系统只有0阶和2阶内存块时的分配情况。</p>
<p><img src="../../../static/img/image-20200403231746644.png" alt="image-20200403231746644"></p>
<p>本文首先介绍了linux内存区域的概念，然后详细描述了伙伴系统算法中分配算法和回收算法，最后简要的描述了伙伴系统算法在分配时区域的选择。</p>
<h3 id="内存区域">内存区域</h3>
<p>UMA（Uniform-Memory-Access）模型：物理存储器被所有处理机均匀共享。所有处理机对所有存储字具有相同的存取时间，这就是为什么称它为均匀存储器存取的原因。每台处理机可以有私用高速缓存,外围设备也以一定形式共享。</p>
<p>NUMA（Non-Uniform-Memory-Access）模型：NUMA模式下，处理器被划分成多个&quot;节点&quot;（node）， 每个节点被分配有的本地存储器空间。 所有节点中的处理器都可以访问全部的系统物理存储器，但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多。</p>
<p>UMA可以看成NUMA特例。下图是内存区域管理结构，<code>pg_data_t</code>代表着一个节点，<code>zones</code>存储着每个内存区域的物理页的数据结构<code>struct page</code>。</p>
<p><img src="../../../static/img/image-20200403225121981.png" alt="image-20200403225121981"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">pglist_data</span> <span class="p">{</span> 
    <span class="k">struct</span> <span class="n">zone</span> <span class="n">node_zones</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span> 	<span class="c1">//内存分区，ZONE_DMA, ZONE_NORMAL, ZONE_HIGHMEM
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zonelist</span> <span class="n">node_zonelists</span><span class="p">[</span><span class="n">MAX_ZONELISTS</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">nr_zones</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">node_mem_map</span><span class="p">;</span> 				<span class="c1">//该节点物理内存中每一页的页框描述符
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_start_pfn</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_present_pages</span><span class="p">;</span>  
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_spanned_pages</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">node_id</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">pgdat_next</span><span class="p">;</span> 
    <span class="n">wait_queue_head_t</span> <span class="n">kswapd_wait</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kswapd</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">kswapd_max_order</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">pg_data_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在内存中，每个node又被分成的区，它们各自描述在内存中的范围。一个管理区(zone)由<code>struct zone</code>结构体来描述，下面是可能分区的情况：</p>
<ol>
<li>ZONE_DMA标记适合DMA的内存域。该区域的长度依赖于处理器类型。在IA-32计算机上，一般的限制是16 MiB，这是由古老的ISA设备强加的边界，因此现代的计算机也可能受这一限制的影响。</li>
<li>ZONE_DMA32标记了使用32位地址字可寻址、适合DMA的内存域。显然，只有在64位系统上，两种DMA内存域才有差别。在32位计算机上，本内存域是空的，即长度为0 MiB。在Alpha和AMD64系统上，该内存域的长度可能从0到4 GiB。</li>
<li>ZONE_NORMAL标记了可直接映射到内核段的普通内存域。这是在所有体系结构上保证都会存在的唯一内存域，但无法保证该地址范围对应了实际的物理内存。例如，如果AMD64系统有2 GiB内存，那么所有内存都属于ZONE_DMA32范围，而ZONE_NORMAL则为空。</li>
<li>ZONE_HIGHMEM标记了超出内核段的物理内存，对应着IA-32计算机上896MB以上的物理内存。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">zone</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_min</span><span class="p">,</span> <span class="n">pages_low</span><span class="p">,</span> <span class="n">pages_high</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lowmem_reserve</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span> 
    <span class="k">struct</span> <span class="n">per_cpu_pageset</span> <span class="n">pageset</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span> 
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">free_area</span> <span class="n">free_area</span><span class="p">[</span><span class="n">MAX_ORDER</span><span class="p">];</span>	<span class="c1">//伙伴系统算法
</span><span class="c1"></span>    <span class="n">ZONE_PADDING</span><span class="p">(</span><span class="n">_pad1_</span><span class="p">)</span> 
    <span class="cm">/* 通常由页面收回扫描程序访问的字段 */</span> 
    <span class="n">spinlock_t</span> <span class="n">lru_lock</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">active_list</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">inactive_list</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scan_active</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scan_inactive</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_scanned</span><span class="p">;</span> <span class="cm">/* 上一次回收以来扫描过的页 */</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 内存域标志，见下文 */</span> 
    <span class="cm">/* 内存域统计量 */</span> 
    <span class="n">atomic_long_t</span> <span class="n">vm_stat</span><span class="p">[</span><span class="n">NR_VM_ZONE_STAT_ITEMS</span><span class="p">];</span> 
    <span class="kt">int</span> <span class="n">prev_priority</span><span class="p">;</span> 
    <span class="n">ZONE_PADDING</span><span class="p">(</span><span class="n">_pad2_</span><span class="p">)</span> 
    <span class="cm">/* 很少使用或大多数情况下只读的字段 */</span> 
    <span class="n">wait_queue_head_t</span> <span class="o">*</span> <span class="n">wait_table</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_hash_nr_entries</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wait_table_bits</span><span class="p">;</span> 
    <span class="cm">/* 支持不连续内存模型的字段。 */</span> 
    <span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">zone_pgdat</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_start_pfn</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spanned_pages</span><span class="p">;</span> <span class="cm">/* 总长度，包含空洞 */</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">present_pages</span><span class="p">;</span> <span class="cm">/* 内存数量（除去空洞） */</span> 
    <span class="cm">/* 
</span><span class="cm">    * 很少使用的字段：
</span><span class="cm">    */</span> 
     <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_maxaligned_in_smp</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">free_area</span> <span class="p">{</span> 
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_list</span><span class="p">[</span><span class="n">MIGRATE_TYPES</span><span class="p">];</span> 	<span class="c1">//反内存碎片机制
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_free</span><span class="p">;</span> 						
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="分配算法">分配算法</h3>
<p>当内核请求分配内存时，伙伴系统执行分配算法以满足其需求。分配算法的基本思想是寻找能够满足内核需求的最小空闲内存块，如果该内存块的阶大于内核请求的阶，则将其逐步划分为一系列低阶内存块，直到划分出恰好满足需求的一个内存块，并分配给内核使用。其余低阶内存块按其所属的阶被依次插入相应的空闲链表，用于满足今后的内存请求。</p>
<p>假设当前内存的分布情况如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">free_area</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">nr_free</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">free_area</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">nr_free</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">free_area</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">nr_free</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>内核请求分配一个1 阶空闲内存块，对于 free_area 数组的查找将从 1 阶开始。由于 1 阶的空闲链表为空，因此继续查找高阶空闲链表，直到发现 3 阶空闲链表非空，查找结果为 3，这说明存在一个 3 阶的空闲内存块可供分配。然后，从 3 阶空闲链表移除第一个内存块的首页描述符，并用 page 指针指向它。同时计算 <code>free_area[3].nr_free--</code>。</p>
<p>由于找到的空闲内存块的尺寸 (3 阶) 超过了内核请求的尺寸 (1 阶)，因此需要划分.。首先将其等分为<strong>两个（二分伙伴算法的名字来源）</strong> 2 阶内存块, 其中高地址端一块的首页描述符指针为 <code>page + 4</code>，将其插入2阶空闲链表，并计算<code>free_area[2].nr_free++</code>。然后，进一步划分低地址端的另一个2阶内存块，将其等分为两个1阶内存块。高地址端一块的首页描述符指针为<code>page+2</code>，将其插入1阶空闲链表，并计算<code>free_area[1].nr_free++</code>。剩下低地址端的一块1阶内存块恰好满足内核的需求，因此停止划分。</p>
<h3 id="回收算法">回收算法</h3>
<p>伙伴系统回收算法的基本思想是首先确定待回收内存块的伙伴，如果伙伴是空闲的，则将二者合并为一个高阶空闲内存块。重复上述合并过程, 直至伙伴不再空闲或合并形成的空闲内存块达到最高阶。在上述过程中，每次合并前都要将伙伴从其所在的空闲链表中移除。合并完成后，最终形成的高阶空闲内存块被插入相应空闲链表的表头。不难看出，回收算法的一项重要的工作是确定待回收内存块的伙伴：</p>
<p>两个内存块互为伙伴 (Buddy) 当且仅当满足以下三个条件：</p>
<ol>
<li>二者在内存中<strong>相邻</strong>且不重叠；</li>
<li>二者具有<strong>相同的阶</strong>；</li>
<li>假设二者的阶都为k，则合并后形成一个k+1阶空闲内存块。</li>
</ol>
<p>我们知道linux采用数组的方式维护每一个物理页的数据结构<code>struct page</code>，即<code>mem_map</code>。所以通过<code>mem_map[page_addr&gt;&gt;12]</code>可以获得某物理页的<code>struct page</code>。该结构中包含了该页是否为空闲的状态。所以可以通过<code>mem_map[(page_addr&gt;&gt;12)-2^k]</code>确定左伙伴是否为空闲；通过<code>mem_map[(page_addr&gt;&gt;12)+2^k]</code>确定右伙伴是否为空闲。</p>
<h4 id="分配区域的选择">分配区域的选择</h4>
<p>我们知道Linux内存分为结点，在结点内部分为区域，每一个区域由伙伴系统算法管理。伙伴系统算法在分配时首先会考虑当前结点是否有充足的内存，其次才会考虑从其它结点借用内存。节点内部分配的优先级从高到低依次是：ZONE_HIGHMEM、ZONE_NORMAL和ZONE_DMA。</p>
<h3 id="参考索引">参考索引</h3>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>薛峰.Linux内核伙伴系统分析[J].计算机系统应用,2018,27(01):174-179. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="https://glemontree.github.io/2017/10/23/%5BLinux%5D%20Linux%E4%B8%AD%E7%9A%84%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%92%8Cslab%E6%9C%BA%E5%88%B6/">https://glemontree.github.io/2017/10/23/[Linux]%20Linux%E4%B8%AD%E7%9A%84%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%92%8Cslab%E6%9C%BA%E5%88%B6/</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" term="伙伴系统" label="伙伴系统" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">多车编队 领航跟随法</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E9%A2%86%E8%88%AA%E8%B7%9F%E9%9A%8F%E6%B3%95/" />
            <id>https://chengshuyi.github.io/posts/robot/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F-%E9%A2%86%E8%88%AA%E8%B7%9F%E9%9A%8F%E6%B3%95/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-03T11:27:11+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[跟随者领航者法的基本思想是将编队控制问题转化为跟随者跟踪领航者的位置和方向的问题。在多机器人组成的群体中，某个机器人被指定为领航者，其余作为它的跟随者，跟随者以一定的距……]]></summary>
            
                <content type="html"><![CDATA[<p>跟随者领航者法的基本思想是将编队控制问题转化为跟随者跟踪领航者的位置和方向的问题。在多机器人组成的群体中，某个机器人被指定为领航者，其余作为它的跟随者，跟随者以一定的距离间隔跟踪领航机器人的位置和方向。</p>
<p>跟随者通过跟踪功能强大的领航者实现预期的目标，当领航者的位置等参量发生变化时，跟随者机器人通过比较这些参量的误差得到控制量并引导行为。对于跟随领航者法有两种控制器形式：$l-l$ 控制器和$l-\varphi$控制器。$l-\varphi$控制器的控制目标是使跟随者和领航者之间的距离和相对转角达到设定值。$l-l$控制器考虑的是三个机器人之间的相对位置问题。当跟随者和两个领航者之间的距离达到设定值的话，就可以认为整个队形稳定了<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<p>这种方法的优点是比较容易实现编队控制。能够实现硬件资源的合理配置，减少了跟随机器人间的相互干扰，因为编队的所有轨迹均有领航者提供，同时跟随者只需跟随领航者运行，不需配置像领航者那样强大的传感器资源，只需配置满足任务需要的传感器即可。但是，这种方法采用的集中式控制使得编队的抗干扰能力较差，如果领航者受到破坏或者因为某种原因不能正常运行，整个编队的正常运行将不能得到保证，再者，所有跟随者都需要与领航者通信，使得领航者的通信负担重，使得这种方法不适用于跟随者较多的情形[^3]。</p>
<h3 id="建立模型2">建立模型<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></h3>
<p>领航跟随编队控制算法可以分为两个部分: 一是确定领航者及队形。二是跟随者跟随领航者。第一部分比较容易实现，可以根据实际情况确定。第二部分比较复杂，是算法的重点。在上面模型中领航跟随法的控制也就是控制领航者和跟随者之间的间距 $l$ 与角度 $\varphi$。这种编队控制的主要思想是: 控制间距 $l$ 和角度 $\varphi$，使之与期望的间距 $l_d$和期望的角度 $\varphi_d$相等。使跟随机器人以角度 $\varphi$ 和间距 $l$ 跟踪领航机器人，从而形成编队。领航者只需要沿着预定规划的路径行走，跟随者需要知道领航者的位置坐标$( x_1，y_1)$ 、角度 $\theta_1$、速度 $v_1$、角速度 $\omega_1$及自身的位置坐标$( x_2，y_2)$ 、角度 $\theta_2$，通过计算确定自身的前进速度 $v_2$、角速度 $\omega_2$来完成编队控制。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200403130104645.png" alt=""></p>
<p>使用参考点的坐标来表示机器人描述中的坐标。机器人描述向量 $r_i= ( x_i，y_i，\theta_i，v_i，\omega_i) $描述机器人 $i$ 的位置坐标、角度、前进速度和角速度，则领航者机器人的描述向量为 $r_1= ( x_1，y_1，\theta_1，v_1，\omega_1)$ ，跟随机器人的描述向量为 $r_2= ( x_2，y_2，\theta_2，v_2，\omega_2)$ 。根据上图中的模型可以得出机器人描述向量各个量之间的关系:</p>
<div>
$$
\left\{\begin{array}{1}
\dot{x}=v_{i} \cos \theta_i \\
\dot{y}=v_{i} \sin \theta_i \\ 
\dot{\theta}_{i}=\omega_{i}
\end{array}\right.
$$
</div>
<blockquote>
<p>注：单位时间内位姿的变化量。</p>
</blockquote>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200403130200690.png" alt="image-20200403130200690"></p>
<p>根据上图的控制关系，跟随机器人的运动学方程为:</p>
<div>
$$
\left\{\begin{array}{l}
\dot{l}=v_{2} \cos \gamma-v_{1} \cos \varphi+d \omega_{2} \sin \gamma \\
\dot{\varphi}=\frac{1}{l}\left(v_{1} \sin \varphi-v_{2} \sin \gamma+d \omega_{2} \cos \gamma-l \omega_{1}\right) \\
\dot{\theta}_{2}=\omega_{2} \tag{2}
\end{array}\right.
$$
</div>
<p>其中 $γ = \varphi + \theta_1－ \theta_2$。</p>
<p>根据算法原理结合结构图的闭环特性可得:</p>
<div>
$$
\left\{\begin{array}{1}
\dot{l}=\alpha(l_d-l) \\
\dot{\varphi}=\beta(\varphi_d-\varphi)
\end{array}\right.\tag{3}
$$
</div>
<blockquote>
<p>通过控制使得$l$和$\varphi$逐渐达到期望值$l_d$和$\varphi_d$，最终$l$和$\varphi$单位时间内的变化量为0。</p>
</blockquote>
<p>式中的 $α，β$ 是闭环控制中的比例系数，联合(2) 式和(3) 式可得跟随机器人的速度$( v_2，\omega_2)$ ，即控制系统的输出：</p>
<div>
$$
\left\{\begin{array}{l}
\omega_{2}=\frac{\cos \gamma}{d}\left[\beta l\left(\varphi_{d}-\varphi\right)-v_{1} \sin \varphi+l \omega_{1}+p \sin \gamma\right] \\
v_{2}=p-d \omega_{2} \tan \gamma \tag{4}
\end{array}\right.
$$
</div>
其中$p=\frac{v_icos\varphi+\alpha(l_d-l)}{cos\gamma}$由( 4) 式得出跟随机器人的控制输入量$( v_2，\omega_2)$ 。根据上面结果输入跟随机器人的控制量来控制跟随机器人的前进速度与角速度，从而完成领航跟随编队控制算法的队形保持，实现编队控制。
<h3 id="参考文献">参考文献</h3>
<p>[] 陈传均. 多机器人领航—跟随型编队控制研究[D]. 杭州电子科技大学. ↩</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>胡玮韬.多机器人编队及运动控制研究[D].陕西:西安电子科技大学,2010. DOI:10.7666/d.y1668394. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>赵明, 林茂松, 黄玉清. Leader-following Formation Control of Multi-robots Based on Dynamic Value of $\varphi$%基于动态\varphi值的领航跟随法多机器人编队控制[J]. 西南科技大学学报, 2013, 028(004):57-61. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" term="机器人" label="机器人" />
                            
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/%E5%A4%9A%E8%BD%A6%E7%BC%96%E9%98%9F/" term="多车编队" label="多车编队" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Slab分配器</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/slab/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/slab/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-02T16:24:50+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[在linux内核中伙伴系统用来管理物理内存，其分配的基本单位是页。由于伙伴系统分配的粒度又太大，因此linux采用slab分配器提供动态内存的管理功能，而且可以作为经常……]]></summary>
            
                <content type="html"><![CDATA[<p>在linux内核中伙伴系统用来管理物理内存，其分配的基本单位是页。由于伙伴系统分配的粒度又太大，因此linux采用slab分配器提供动态内存的管理功能，而且可以作为经常分配并释放的对象的高速缓存。slab分配器的优点：</p>
<ol>
<li>
<p>可以提供小块内存的分配支持，通用高速缓存可分配的大小从$2^5B$到$2^{25}B$，专用高速缓存没有大小限制；</p>
</li>
<li>
<p>不必每次申请释放都和伙伴系统打交道，提供了分配释放效率；</p>
</li>
<li>
<p>如果在slab缓存的话，其在CPU高速缓存的概率也会较高；</p>
</li>
<li>
<p>伙伴系统对系统的数据和指令高速缓存有影响，slab分配器采用着色降低了这种副作用。</p>
</li>
</ol>
<p>伙伴系统分配的内存大小是页的倍数，不利于CPU的高速缓存：如果每次都将数据存放到从伙伴系统分配的页开始的位置会使得高速缓存的有的行被过度使用，而有的行几乎从不被使用[<strong>cpu的L1 cache一般大小为32KB，采用伙伴系统分配$order\geq5$时就会出现上述的问题</strong>]。slab分配器通过着色使得slab对象能够均匀的使用高速缓存，提高高速缓存的利用率。</p>
<h3 id="基本数据结构">基本数据结构</h3>
<p><code>struct kmem_cache</code>、<code>struct array_cache</code>、<code>struct kmem_cache_node</code></p>
<p>程序经常需要创建一些数据结构，比如进程描述符task_struct，内存描述符mm_struct等。slab分配器把这些需要分配的小块内存区作为对象，类似面向对象的思想。每一类对象分配一个cache，cache有一个或多个slab组成，slab由一个或多个物理页面组成。需要分配对象的时候从slab中空闲的对象取，用完了再放回slab中，而不是释放给物理页分配器，这样下次用的时候就不用重新初始化了，实现了对象的复用。</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/image-20200402195625069.png" alt=""></p>
<h3 id="鸡和蛋问题">鸡和蛋问题</h3>
<p>由于slab分配器对象（<code>struct kmem_cache、struct array_cache、struct kmem_cache_node</code>）也需要用slab分配器提供的高速缓存机制，那么问题是：先有高速缓存还是先有slab分配器对象。</p>
<ol>
<li>我们知道slab分配器对象用来管理高速缓存：假设先有高速缓存的话，那么谁来管理高速缓存呢？</li>
<li>我们知道高速缓存用来存放slab分配器对象：假设先有slab分配器对象，那么它存放在哪里呢？</li>
</ol>
<p>linux的做法是：静态分配slab分配器对象内存空间，然后利用伙伴算法分配存储对象的页帧。</p>
<h3 id="slab着色原理">slab着色原理</h3>
<p>一般情况下，slab的大小为4KB。我们令cpu的L1 cache为32KB（每一行64B、512行），那么要填充满cpu的L1 cache需要8个slab。那么slab分配器会从伙伴分配系统中分配8个slab，也就是8个页（8个页不一定是物理连续的）。假设获取的8个页对应的的起始地址和终止地址如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="mh">0x10000000</span> <span class="o">-</span> <span class="mh">0x10001000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10010000</span> <span class="o">-</span> <span class="mh">0x10011000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10020000</span> <span class="o">-</span> <span class="mh">0x10021000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10030000</span> <span class="o">-</span> <span class="mh">0x10031000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10040000</span> <span class="o">-</span> <span class="mh">0x10041000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10050000</span> <span class="o">-</span> <span class="mh">0x10051000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10060000</span> <span class="o">-</span> <span class="mh">0x10061000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
<span class="mh">0x10070000</span> <span class="o">-</span> <span class="mh">0x10071000</span><span class="err">：对应</span><span class="n">cache行是0</span><span class="o">-</span><span class="mi">64</span>
</code></pre></td></tr></table>
</div>
</div><p>可以发现不同的slab起始地址映射到cpu cache的同一行。slab着色原理是利用浪费的空间，假设浪费的空间所占用的cache行是$[1,10)$。那么slab中对象实际占用的cache行是$0\cup[11,64)$。那么可以通过偏移来让部分的对象移动到$[1,10)$行内。尽管slab着色可以使得对象尽可能占满cache，但是slab的着色仍然有很大的限制：</p>
<ol>
<li>无法占满剩余的行数，上述实例中$[64,512)$仍然未被使用；</li>
<li>当slab的个数超过颜色数，效果甚微；</li>
<li>slab的着色是用空间换时间，浪费一些空间来提高cache的命中率。</li>
</ol>
<!--http://www.secretmango.com/jimb/Whitepapers/slabs/slab.html-->]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/linux%E5%86%85%E6%A0%B8/" term="linux内核" label="linux内核" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/linux%E5%86%85%E6%A0%B8slab%E5%88%86%E9%85%8D%E5%99%A8/" term="linux内核、slab分配器" label="linux内核、slab分配器" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">作用域、链接、存储类型</title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/c/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/" />
            <id>https://chengshuyi.github.io/posts/c/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>2020-04-02T13:41:27+08:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[在开发中经常会使用到static和extern等关键字，它们会涉及到c语言中的作用域、链接和存储期等概念。作用域和链接描述了标识符的可见性，存储期描述了通过这些标识符访……]]></summary>
            
                <content type="html"><![CDATA[<p>在开发中经常会使用到static和extern等关键字，它们会涉及到c语言中的作用域、链接和存储期等概念。作用域和链接描述了标识符的可见性，存储期描述了通过这些标识符访问的对象的生存期。</p>
<h3 id="作用域">作用域</h3>
<p>作用域描述了标识符可见范围，包括：文件作用域、代码块作用域、函数作用域、函数原型作用域。</p>
<h4 id="文件作用域">文件作用域</h4>
<p>在所有代码块之外的声明的标识符具有文件作用域；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>先声明再使用；</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 				<span class="c1">//error: &#39;a&#39; was not declared in this scope
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="代码块作用域">代码块作用域</h4>
<p>花括号之间声明的标识符具有块作用域；</p>
<blockquote>
<p>函数定义的形式参数也具有块作用域。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 				<span class="c1">//error: &#39;a&#39; was not declared in this scope
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="函数原型作用域">函数原型作用域</h4>
<p>函数原型中声明的参数名具有函数原型作用域；范围是从形参定义处到函数原型声明的结束。</p>
<blockquote>
<p>唯一要注意的是在函数原型中的参数名字不能重复；</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//redefinition of &#39;int a&#39;
</span></code></pre></td></tr></table>
</div>
</div><h4 id="函数作用域">函数作用域</h4>
<p>一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数；</p>
<blockquote>
<p>只适用于语句标签</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
<span class="nl">ret</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">goto</span> <span class="n">ret</span><span class="p">;</span>			<span class="c1">//error: label &#39;ret&#39; used but not defined
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="nl">ret</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="nl">ret</span><span class="p">:</span> 			<span class="c1">//error: duplicate label &#39;ret&#39;
</span><span class="c1"></span>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="链接属性">链接属性</h3>
<p>C 变量有 3 种链接属性：外部链接、内部链接或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是外部链接或内部链接。<strong>外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用</strong>。</p>
<p>static关键字可以使一个<strong>外部链接</strong>变成内部链接（<strong>注意：1. 无法将无链接的变成内部链接，比如在函数内声明static变量，其链接属性仍然是无连接。2. static无法改变标识符的作用域</strong>），即每一个翻译单元都单独享有static声明的标识符。本例有两个源文件：<code>file1.c</code>和<code>file2.c</code>，源文件都包含同一个头文件<code>file.h</code>。具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//file.h 
</span><span class="c1"></span><span class="cp">#ifndef TEST_FILE_H
</span><span class="cp">#define TEST_FILE_H
</span><span class="cp"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">file1_modify_static</span><span class="p">();</span>
<span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//file1.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;file.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">file1_modify_static</span><span class="p">(){</span>
	<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__func__</span><span class="o">&lt;&lt;</span><span class="s">&#34;: a is &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//file2.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;file.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__func__</span><span class="o">&lt;&lt;</span><span class="s">&#34;: a is &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">file1_modify_static</span><span class="p">();</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">__func__</span><span class="o">&lt;&lt;</span><span class="s">&#34;: a is &#34;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最终的输出是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">main</span><span class="p">:</span> <span class="n">a</span> <span class="n">is</span> <span class="mi">0</span>
<span class="nl">file1_modify_static</span><span class="p">:</span> <span class="n">a</span> <span class="n">is</span> <span class="mi">1</span>
<span class="nl">main</span><span class="p">:</span> <span class="n">a</span> <span class="n">is</span> <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到文件1和文件2修改的a不是同一个a，说明static将变量a变成了内部链接。</p>
<h3 id="存储期">存储期</h3>
<p>C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。这里主要需要了解静态存储期和自动存储期：</p>
<ol>
<li>
<p>如果对象具有静态存储期，那么它在程序的执行期间一直存在。</p>
</li>
<li>
<p>块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。</p>
</li>
</ol>
<h3 id="总结">总结</h3>
<p><img src="C:%5CUsers%5Cc1527%5CDesktop%5Chugo_0.68.3_Windows-64bit%5Cblog%5Cstatic%5Cimg%5Cimage-20200402133937695.png" alt="image-20200402133937695"></p>
<blockquote>
<p>static关键字的作用</p>
</blockquote>
<ol>
<li>
<p>static用于修改标识符的链接属性，将其链接属性从<strong>外部链接</strong>转换成内部链接，使得改标识符只能由该源文件访问，但标识符的存储期和作用域不受影响；</p>
<blockquote>
<p>外部链接和内部链接的存储期和作用域都一样，属于：文件作用域，静态存储期</p>
</blockquote>
</li>
<li>
<p>static用于块作用域的标识符声明时，将其从自动变量转换成静态变量，但变量的链接属性和作用域不受影响。</p>
</li>
</ol>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/categories/c%E8%AF%AD%E8%A8%80/" term="c语言" label="c语言" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://chengshuyi.github.io/tags/c%E8%AF%AD%E8%A8%80c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" term="c语言、c语言基础概念" label="c语言、c语言基础概念" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text"></title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/computer-network/untitled/" />
            <id>https://chengshuyi.github.io/posts/computer-network/untitled/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>0001-01-01T00:00:00+00:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[Two key network-core functions ​ routing ​ forwarding Alternative core: circuit switching four sources of packet delay securty ​ packet sniffing:broadcast media ​ ip spoofing: send packet with false source address Application architectures ​ client-server ​ peer-to-peer (P2P) ​ TCP service: reliable transport between sending and receiving process flow control: sender won’t overwhelm receiver congestion control: throttle sender when network overloaded does not provide: timing, minimum throughput guarantee, security connection-oriented: setup required between client and server processes UDP service: unreliable……]]></summary>
            
                <content type="html"><![CDATA[<p>Two key network-core functions</p>
<p>​	routing</p>
<p>​	forwarding</p>
<p>Alternative core: circuit switching</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200429211649.png" alt=""></p>
<p>four sources of packet delay</p>
<p><img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200429211926.png" alt=""></p>
<p>securty</p>
<p>​	packet sniffing:broadcast media</p>
<p>​	ip spoofing: send packet with false source address</p>
<p>Application architectures</p>
<p>​	client-server
​	peer-to-peer (P2P)</p>
<p>​	TCP service:
reliable transport between sending and receiving process
flow control: sender won’t overwhelm receiver
congestion control: throttle sender when network overloaded
does not provide: timing, minimum throughput guarantee, security
connection-oriented: setup required between client and server processes</p>
<p>UDP service:
unreliable data transfer between sending and receiving process
does not provide: reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup,</p>
<p>Q: why bother?  Why is there a UDP?</p>
<p>securing tcp</p>
<p>web and http</p>
<p>​	non-persistent HTTP</p>
<p>​	persistent HTTP</p>
<hr>
<h3 id="国立清华大学">国立清华大学</h3>
<p>domain name(domain name server) -&gt; ip address :  about 6 message to find ip address</p>
<p>3 message for connection establishment of tcp</p>
<p>4</p>
<p>4</p>
<p>point-to-point  multiple access</p>
<p>peer-to-peer</p>
<p>spanning tree：任何两个结点之间只有一条路径</p>
<p>封包最大值 每个网路不一样</p>
<p>statistical multiplexing:fifo rr priorities</p>
<p>bandwidth</p>
<p>latency</p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text"></title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/cse/" />
            <id>https://chengshuyi.github.io/posts/cse/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>0001-01-01T00:00:00+00:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html"><![CDATA[01 Coping with complexity
Modularity Abstraction Layering Hierarchy Start with a small group of modules Assemble them into a stable, self-contained subsystem with well defined interface Assemble a group of subsystems to a larger subsystem
02 L1: Block Layer Mapping: block number -&gt; block data Super Block the size of block which block is free Kernel reads superblock when mount the FS L2: File Layer inode (index node) A container for metadata about the file block, indrect block, double indirect block, triple indirect block]]></summary>
            
                <content type="html"><![CDATA[<p>01
Coping with complexity<br>
Modularity
Abstraction
Layering
Hierarchy
Start with a small group of modules
Assemble them into a stable, self-contained subsystem with well defined interface Assemble a group of subsystems to a larger subsystem</p>
<p>02
<img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200427112323.png" alt=""></p>
<p>L1: Block Layer
Mapping: block number -&gt; block data
Super Block
the size of block
which block is free
Kernel reads superblock when mount the FS
L2: File Layer
inode (index node)
A container for metadata about the file
block, indrect block, double indirect block, triple indirect block</p>
<p>L3: inode Number Layer
Mapping: inode number -&gt; inode</p>
<pre><code>![](https://gitee.com/chengshuyi/scripts/raw/master/img/20200427113436.png)
inode number is enough to operate a file 
</code></pre>
<p>L4: File Name Layer
L5: Path Name Layer
link
unlink
rename
L6: Absolute Path Name Layer
L7: Symbolic LinkLayer
mount
Record the device and the root inode number of the file system in memory
Record in the in-memory version of the inode for &quot;/dev/fd1&quot; its parent’s inode
link</p>
<p>FAT (File Allocation Table) File System
File is collection of disk blocks
In FAT: file attributes are kept in directory</p>
<p>03
Directly Dump a Directory
Two Types of Links
Hard link
Soft link
Soft link can create cycle by SYMLINK(&quot;a&quot;, &quot;a&quot;)
<img src="https://gitee.com/chengshuyi/scripts/raw/master/img/20200427133254.png" alt="">
--</p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text"></title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/leet/" />
            <id>https://chengshuyi.github.io/posts/leet/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>0001-01-01T00:00:00+00:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html"><![CDATA[notes1
A relation is an unordered set that contains the relationship of attributes that represent entities. Since the relationships are unordered, the DBMS can store them in any way it wants, allowing for optimization.
A tuple is a set of attribute values (also known as its domain) in the relation. Originally, values had to be atomic or scalar, but now values can also be lists or nested data structures. Every attribute can be a special value, NULL, which means for a given tuple the attribute is undefined.]]></summary>
            
                <content type="html"><![CDATA[<p>notes1</p>
<p>A relation is an unordered set that contains the relationship of attributes that represent entities. Since the
relationships are unordered, the DBMS can store them in any way it wants, allowing for optimization.</p>
<p>A tuple is a set of attribute values (also known as its domain) in the relation. Originally, values had to be
atomic or scalar, but now values can also be lists or nested data structures. Every attribute can be a special
value, NULL, which means for a given tuple the attribute is undefined.</p>
<p>A relation with n attributes is called an n-ary relation.</p>
<p>Data Manipulation Languages (DMLs)
Relational Algebra</p>
<p>select type,primary_title,runtime_minutes from titles where runtime_minutes in (select runtime_minutes from titles order by runtime_minutes desc limit 1) order by type asc, primary_title asc;</p>
<p>select type, count(<em>) FROM titles GROUP BY type ORDER BY count(</em>) ASC</p>
<p>select cast(premiered/10<em>10 as varchar)||'s',count(</em>) from titles where premiered NOT NULL group by premiered/10;</p>
<p>select cast(premiered/10<em>10 as varchar)||'s',round(count(</em>)<em>100.0/(select count(</em>) from titles),4) from titles where premiered NOT NULL group by premiered/10;</p>
<p>select primary_title,b.num from titles as a, (select title_id,count(<em>) as num from akas group by title_id order by count(</em>) desc limit 10) as b where a.title_id = b.title_id;</p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
        <entry>
            <title type="text"></title>
            <link rel="alternate" type="text/html" href="https://chengshuyi.github.io/posts/linux-kernel/untitled/" />
            <id>https://chengshuyi.github.io/posts/linux-kernel/untitled/</id>
            <updated>2020-06-17T13:19:11+00:00</updated>
            <published>0001-01-01T00:00:00+00:00</published>
            <author>
                    <name>程书意</name>
                    <uri>https://chengshuyi.github.io</uri>
                    <email>c15271843451@outlook.com</email>
                    </author>
            <rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights>
    
    <summary type="html"><![CDATA[SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count) call ksys_read ​ call fdget_pos // convert long fd to struct fd ​ call vfs_read ​ call rw_verify_area ​ call __vfs_read ​ call file-&gt;f_op-&gt;read(file, buf, count, pos); 假设我们使用的ext4文件系统 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const struct file_operations ext4_file_operations = { .llseek = ext4_llseek, .read_iter = ext4_file_read_iter, .write_iter =……]]></summary>
            
                <content type="html"><![CDATA[<p>SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)</p>
<p>call ksys_read</p>
<p>​	call fdget_pos // convert long fd to struct fd</p>
<p>​	call vfs_read</p>
<p>​		call rw_verify_area</p>
<p>​		call __vfs_read</p>
<p>​			call file-&gt;f_op-&gt;read(file, buf, count, pos);</p>
<p>假设我们使用的ext4文件系统</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext4_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">ext4_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_iter</span>	<span class="o">=</span> <span class="n">ext4_file_read_iter</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_iter</span>	<span class="o">=</span> <span class="n">ext4_file_write_iter</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">ext4_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT
</span><span class="cp"></span>	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">ext4_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="cp"></span>	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">ext4_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap_supported_flags</span> <span class="o">=</span> <span class="n">MAP_SYNC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ext4_file_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">ext4_release_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">ext4_sync_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_unmapped_area</span> <span class="o">=</span> <span class="n">thp_get_unmapped_area</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_write</span>	<span class="o">=</span> <span class="n">iter_file_splice_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fallocate</span>	<span class="o">=</span> <span class="n">ext4_fallocate</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>call ext4_file_read_iter</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_DIRECT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ext4_dio_read_iter</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="k">return</span> <span class="nf">generic_file_read_iter</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>call generic_file_read_iter</p>
<p>call generic_file_buffered_read</p>
<p>check page cache</p>
<p>call error = mapping-&gt;a_ops-&gt;readpage(filp, page);</p>
<p>(1) 页缓存（page cache）针对以页为单位的所有操作，并考虑了特定体系结构上的页长度。一个</p>
<p>主要的例子是许多章讨论过的内存映射技术。因为其他类型的文件访问也是基于内核中的这一技术实</p>
<p>现的，所以页缓存实际上负责了块设备的大部分缓存工作。</p>
<p>(2) 块缓存（buffer cache）以块为操作单位。在进行I/O操作时，存取的单位是设备的各个块，而</p>
<p>不是整个内存页。尽管页长度对所有文件系统都是相同的，但块长度取决于特定的文件系统或其设置。</p>
<p>因而，块缓存必须能够处理不同长度的块。</p>
]]></content>
            
            
            
            
            
                
                    
                
                    
                
            
        </entry>
    
</feed>
